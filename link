#include <iostream>
#include <string>
#include <new>
using namespace std;

#include "C:\Users\CLONEZILLA\Documents\Visual Studio 2008\Projects\Netcell_test\Netcell_test\definitions.h"


// CLASS LINKENDPOINT FUNCTIONS
void LinkEndpoint::LinkEndpoint_init(Identity_s *id, LinkEndpointTraits_s linkEndpointTraits, unsigned int ttl) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkEndpoint, init\n");}

	Identity_s linkEndpointResId;

	linkEndpointResId.type = "LINKENDPOINTRES";
	linkEndpointResId.nickName = "-";
	this->endpointRes.LinkEndpointRes_init(&linkEndpointResId, linkEndpointTraits.attPointTraits, linkEndpointTraits.genTraits);
	myLinkEndpointTraits = linkEndpointTraits;
	Entity_init(id, ttl, 0);
};

void LinkEndpoint::LinkEndpoint_delete() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkEndpoint, delete\n");}

//	if (this->get_identity().name.name == 10464) {
//		SYSTEM->breakExecution(SYSTEM->getTicks());
//	}

	this->Entity_delete();
};

DataDirection LinkEndpoint::get_linkDataDir() {	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkEndpoint, get_linkDataDir\n");} return(myLinkEndpointTraits.attPointTraits.flowdir);}

LinkEndpointTraits_s LinkEndpoint::get_linkEndpointTraits() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkEndpoint, get_linkEndpointTraits\n");}
	return(myLinkEndpointTraits);
};

void LinkEndpoint::CALLBACK_tickZero(void * parameters, int secret) {  // This function is not in use
};
ostream &operator<<(ostream &stream, LinkEndpoint *le) {
	Entity *enp;

	enp = le;
	stream << "LinkEndpoint_Status: " << enp;

	stream << "End_LinkEndpoint_Status\n";
	return stream;
};

// CLASS LINKTOPOLOGY FUNCTIONS
void LinkTopology::LinkTopology_init(Identity_s *id) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, init\n");}
	firstSourceEndpoint = 0;
	destEndpoint = nextDestEndpoint = 0;
	currentNumberSources = currentNumberDestinations = 0;
	identity.Identity_init(id);
}

int LinkTopology::add_linkEndpoint(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, add_linkEndpoint\n");}

	if (linkEndpoint->get_identity().name.name == 12073) {
		cout << "\nEndpoint 12073!\n";
	}

	LinkSourceEndpoint_s *sourceEndpoint, *newSourceEndpoint;
	LinkDestEndpoint_s *destEndpoint, *newDestEndpoint, *newSourceDestEndpoint, *lastNewSourceDestEndpoint;
	bool inList, lastItem, lastRowItem, oldDestFound;

	if (linkEndpoint->get_linkDataDir() != RECEIVER && currentNumberSources == MAX_LINKSOURCES) {SYSTEM->runtimerror(&identity.get_identity(), "add_linkEndpoint","Too_many_source_endpoints", SYS_ERR_HARD);}
	if (linkEndpoint->get_linkDataDir() == RECEIVER && currentNumberDestinations == MAX_LINKDESTINATIONS) {SYSTEM->runtimerror(&identity.get_identity(), "add_linkEndpoint","Too_many_destinations_endpoints", SYS_ERR_HARD);}

	if (linkEndpoint->get_linkDataDir() != RECEIVER && firstSourceEndpoint == 0) { // First source!
		
		try {
			firstSourceEndpoint = new LinkSourceEndpoint_s;
		} catch (bad_alloc xa) {
			SYSTEM->runtimerror(&identity.get_identity(), "add_linkEndpoint","allocation_failure", SYS_ERR_HARD);
		}

		firstSourceEndpoint->previousSource = 0;
		firstSourceEndpoint->linkEndpoint = linkEndpoint;
		firstSourceEndpoint->nodeId = identity.reset_anotherIdentity();
		firstSourceEndpoint->nextSource = 0;
		firstSourceEndpoint->firstDest = 0;

		currentNumberSources++;
	}
	else if (linkEndpoint->get_linkDataDir() != RECEIVER) { // A new additional source
		sourceEndpoint = firstSourceEndpoint;
		inList = false;
		lastItem = false;

		while (lastItem == false && inList == false) {
			if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
				inList = true;
			}

			if (sourceEndpoint->nextSource == 0) {
				lastItem = true;
			}
			else {
				sourceEndpoint = sourceEndpoint->nextSource;
			}
		}
		
		if (inList == false) {
			try {
				newSourceEndpoint = new LinkSourceEndpoint_s;
			} catch (bad_alloc xa) {
				SYSTEM->runtimerror(&identity.get_identity(), "add_linkEndpoint","allocation_failure", SYS_ERR_HARD);
			}

			sourceEndpoint->nextSource = newSourceEndpoint;
			newSourceEndpoint->previousSource = sourceEndpoint;
			newSourceEndpoint->linkEndpoint = linkEndpoint;
			newSourceEndpoint->nodeId = identity.reset_anotherIdentity();
			newSourceEndpoint->nextSource = 0;
			newSourceEndpoint->firstDest = 0;

			currentNumberSources++;

			// Add all existing destinations for this new source
			sourceEndpoint = firstSourceEndpoint;

			while (sourceEndpoint != newSourceEndpoint) {
				destEndpoint = sourceEndpoint->firstDest;
				newSourceDestEndpoint = newSourceEndpoint->firstDest;

				while (destEndpoint != 0) {
					oldDestFound = false;
					lastNewSourceDestEndpoint = newSourceDestEndpoint;

					while (newSourceDestEndpoint != 0 && oldDestFound == false) {

						if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, newSourceDestEndpoint->linkEndpoint->get_identity().name) == true) { // Add this new destination
							 oldDestFound = true;
						}
						else {

							if (newSourceDestEndpoint->nextDest == 0) {
								lastNewSourceDestEndpoint = newSourceDestEndpoint;
							}

							newSourceDestEndpoint = newSourceDestEndpoint->nextDest;
						}

					}  // ENDWHILE newSourceDestEndpoint

					if (oldDestFound == false) {

						try {
							newDestEndpoint = new LinkDestEndpoint_s;
						} catch (bad_alloc xa) {
							SYSTEM->runtimerror(&identity.get_identity(), "add_linkEndpoint","allocation_failure", SYS_ERR_HARD);
						}

						if (lastNewSourceDestEndpoint == 0) {  // First added destination
							newSourceEndpoint->firstDest = newDestEndpoint;
							newDestEndpoint->previousDest = 0;
							newDestEndpoint->linkEndpoint = destEndpoint->linkEndpoint;
							newDestEndpoint->nodeId = destEndpoint->nodeId;
							newDestEndpoint->superNodeId = destEndpoint->superNodeId;
							newDestEndpoint->interfaceId = destEndpoint->interfaceId;
							newDestEndpoint->CALLBACK_functions.CALLBACK_InfFunctions = destEndpoint->CALLBACK_functions.CALLBACK_InfFunctions;
							newDestEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions = destEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions;
							newDestEndpoint->nextDest = 0;
						}
						else {
							lastNewSourceDestEndpoint->nextDest = newDestEndpoint;
							newDestEndpoint->previousDest = lastNewSourceDestEndpoint;
							newDestEndpoint->linkEndpoint = destEndpoint->linkEndpoint;
							newDestEndpoint->nodeId = destEndpoint->nodeId;
							newDestEndpoint->superNodeId = destEndpoint->superNodeId;
							newDestEndpoint->interfaceId = destEndpoint->interfaceId;
							newDestEndpoint->CALLBACK_functions.CALLBACK_InfFunctions = destEndpoint->CALLBACK_functions.CALLBACK_InfFunctions;
							newDestEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions = destEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions;
							newDestEndpoint->nextDest = 0;
						}

					}  // ENDIF oldDestFound

					newSourceDestEndpoint = newSourceEndpoint->firstDest;
					destEndpoint = destEndpoint->nextDest;
				}  // ENDWHILE destEndpoint

				sourceEndpoint = sourceEndpoint->nextSource;
			}  // ENDWHILE sourceEndpoint

		}
	}

	if (linkEndpoint->get_linkDataDir() != TRANSMITTER && firstSourceEndpoint != 0) { // A destination, destinations can not be registered until first source has registered.
		sourceEndpoint = firstSourceEndpoint;
		destEndpoint = sourceEndpoint->firstDest;
		
		// The following logic supports the possibility that not all sources can reach all destinations, restrictions being supported via policies
		inList = false;
		lastItem = false;

		while (lastItem == false && inList == false) {  // Check if new destination is in list

			if (destEndpoint != 0) {
				lastRowItem = false;
			}
			else {
				lastRowItem = true;
			}

			while (lastRowItem == false) {
				if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
					inList = true;
				}

				if (destEndpoint->nextDest == 0) {
					lastRowItem = true;
				}
				else {
					destEndpoint = destEndpoint->nextDest;
				}
			}

			sourceEndpoint = sourceEndpoint->nextSource;
					
			if (sourceEndpoint == 0) {
				lastItem = true;
			}
			else {
				destEndpoint = sourceEndpoint->firstDest;
			}

		}  // End While check if in list.
		
		if (inList == false) {
			// The following logic inserts a new destination for each source without restrictions
			currentNumberDestinations++;
			sourceEndpoint = firstSourceEndpoint;
			destEndpoint = sourceEndpoint->firstDest;
			lastItem = false;

			while (lastItem == false) {

				if (destEndpoint != 0) {
					lastRowItem = false;
				}
				else { // first destination for this specific source

					try {
						newDestEndpoint = new LinkDestEndpoint_s;
					} catch (bad_alloc xa) {
						SYSTEM->runtimerror(&identity.get_identity(), "add_linkEndpoint","allocation_failure", SYS_ERR_HARD);
					}
					sourceEndpoint->firstDest = newDestEndpoint;
					newDestEndpoint->previousDest = 0;
					newDestEndpoint->linkEndpoint = linkEndpoint;
					newDestEndpoint->nodeId = identity.reset_anotherIdentity();
					newDestEndpoint->superNodeId = identity.reset_anotherIdentity();
					newDestEndpoint->interfaceId = identity.reset_anotherIdentity();
					newDestEndpoint->CALLBACK_functions.CALLBACK_InfFunctions = 0;
					newDestEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions = 0;
					newDestEndpoint->nextDest = 0;

					lastRowItem = true;
				}

				while (lastRowItem == false) {
					if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {  // This check should not be needed???
						inList = true;
					}

					if (destEndpoint->nextDest == 0) {
						try {
							newDestEndpoint = new LinkDestEndpoint_s;
						} catch (bad_alloc xa) {
							SYSTEM->runtimerror(&identity.get_identity(), "add_linkEndpoint","allocation_failure", SYS_ERR_HARD);
						}
						destEndpoint->nextDest = newDestEndpoint;
						newDestEndpoint->previousDest = destEndpoint;
						newDestEndpoint->linkEndpoint = linkEndpoint;
						newDestEndpoint->nodeId = identity.reset_anotherIdentity();
						newDestEndpoint->superNodeId = identity.reset_anotherIdentity();
						newDestEndpoint->interfaceId = identity.reset_anotherIdentity();
						newDestEndpoint->CALLBACK_functions.CALLBACK_InfFunctions = 0;
						newDestEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions = 0;
						newDestEndpoint->nextDest = 0;
					
						lastRowItem = true;
					}
					else {
						destEndpoint = destEndpoint->nextDest;
					}
				}

				sourceEndpoint = sourceEndpoint->nextSource;
					
				if (sourceEndpoint == 0) {
					lastItem = true;
				}
				else {
					destEndpoint = sourceEndpoint->firstDest;
				}

			}

		}

	}

	return 0;

}; // END LINKTOPOLOGY::ADD_LINKENDPOINT

int LinkTopology::remove_linkEndpoint(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, remove_linkEndpoint\n");}

	LinkSourceEndpoint_s *sourceEndpoint, *oldSourceEndpoint;
	LinkDestEndpoint_s *destEndpoint, *oldDestEndpoint;
	bool inList, lastRowItem, isSource, isDest;

	if (this->isLinkEndpoint_installed(linkEndpoint) == false) {
		SYSTEM->runtimerror(&identity.get_identity(), "remove_linkEndpoint", "Trying_to_remove_a_non-existing_endpoint", SYS_ERR_HARD);
		return(-1);
	}

	this->remove_linkEndpointInfo(linkEndpoint);

	inList = isSource = isDest = false;
	sourceEndpoint = firstSourceEndpoint;

	// First remove in regard of endpoint being a source, i.e. the following while loop
	while (sourceEndpoint != 0 && isSource == false) {

		if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a TRANSMITTER/TRANCEIVER, remove source and entire row of destinations
			isSource = true;
			inList = true;
			oldSourceEndpoint = sourceEndpoint;
			lastRowItem = false;

			while (lastRowItem == false) {
				destEndpoint = oldSourceEndpoint->firstDest;

				if (destEndpoint == 0) {
					lastRowItem = true;
				}
				else {
					while (lastRowItem == false) {
						oldDestEndpoint = destEndpoint;
						destEndpoint = destEndpoint->nextDest;

						if (destEndpoint == 0) {
							lastRowItem = true;
						}

						delete oldDestEndpoint;
					}
				}
			}

			if (firstSourceEndpoint == sourceEndpoint) {
				firstSourceEndpoint = sourceEndpoint->nextSource;

				if (firstSourceEndpoint != 0) {
					firstSourceEndpoint->previousSource = 0;
				}

			}
			else if (sourceEndpoint->nextSource == 0) {  // Last source
				sourceEndpoint->previousSource->nextSource = 0;
			}
			else {
				LinkSourceEndpoint_s *previousSource, *nextSource;
				previousSource = sourceEndpoint->previousSource;
				previousSource->nextSource = sourceEndpoint->nextSource;
				nextSource = sourceEndpoint->nextSource;
				nextSource->previousSource = previousSource;
			}

			delete oldSourceEndpoint;
			currentNumberSources--;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}

	} // End while (scanned through column of sources)

	// Second, remove in regard of endpoint being a destination, i.e. the following while loop
	sourceEndpoint = firstSourceEndpoint;

	while (sourceEndpoint != 0) {
		destEndpoint = sourceEndpoint->firstDest;
		isDest = false;
		inList = false;
		
		if (destEndpoint == 0) {
			lastRowItem = true;
		}
		else {
			lastRowItem = false;
		}

		while (lastRowItem == false && inList == false) {

			if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a RECEIVER/TRANCEIVER, remove this destination
				isDest = true;
				inList = true;
				oldDestEndpoint = destEndpoint;
				LinkDestEndpoint_s *previousDest, *nextDest;

				if (destEndpoint == sourceEndpoint->firstDest) {
					sourceEndpoint->firstDest = destEndpoint->nextDest;

					if (sourceEndpoint->firstDest != 0) {
						sourceEndpoint->firstDest->previousDest = 0;
					}

				}
				else if (destEndpoint->nextDest == 0) {  // Last destination
					destEndpoint->previousDest->nextDest = 0;
				}
				else {
					previousDest = destEndpoint->previousDest;
					previousDest->nextDest = destEndpoint->nextDest;
					nextDest = destEndpoint->nextDest;
					nextDest->previousDest = previousDest;
				}

				delete oldDestEndpoint;
			}
			else {
				destEndpoint = destEndpoint->nextDest;

				if (destEndpoint == 0) {
					lastRowItem = true;
				}
			}

		} // End while, scanned through entire row of destinations

		sourceEndpoint = sourceEndpoint->nextSource;
	} // End while, scanned through all columns of sources for all destinations

	if (isDest == true) {
		currentNumberDestinations--;
	}

	return 0;
}; // END LINKTOPOLOGY::REMOVE_LINKENDPOINT

bool LinkTopology::isLinkEndpoint_installed(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, isLinkEndpoint_installed\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inList, lastRowItem, isSource, isDest;

	inList = false;
	isSource = false;

	sourceEndpoint = firstSourceEndpoint;

	// Scan to check whether endpoint might be a source
	while (sourceEndpoint != 0 && isSource == false && inList == false) {
		if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a TRANSMITTER/TRANCEIVER
			isSource = true;
			inList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	// Scan to check if endpoint is a destination
	sourceEndpoint = firstSourceEndpoint;

	if (inList == false) {

		while (sourceEndpoint != 0) {
			destEndpoint = sourceEndpoint->firstDest;
			isDest = false;
		
			if (destEndpoint == 0) {
				lastRowItem = true;
			}
			else {
				lastRowItem = false;
			}

			while (lastRowItem == false) {

				if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
				// Endpoint is a RECEIVER/TRANCEIVER
					isDest = true;
					inList = true;
				}
				else {
					destEndpoint = destEndpoint->nextDest;

					if (destEndpoint == 0) {
						lastRowItem = true;
					}
				}

			} // End while, scanned through entire row of destinations

			sourceEndpoint = sourceEndpoint->nextSource;
		} // End while, scanned through all columns of sources for all destinations
	}  // End if inList

	return(inList);
}; // END LINKTOPOLOGY::ISLINKENDPOINT_INSTALLED

bool LinkTopology::isLinkEndpoint_installed(Identity_s *endpointId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, isLinkEndpoint_installed\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inList, lastRowItem, isSource, isDest;

	inList = false;
	isSource = false;

	sourceEndpoint = firstSourceEndpoint;

	// Scan to check whether endpoint might be a source
	while (sourceEndpoint != 0 && isSource == false && inList == false) {
		if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, endpointId->name) == true) {
			// Endpoint is a TRANSMITTER/TRANCEIVER
			isSource = true;
			inList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	// Scan to check if endpoint is a destination
	sourceEndpoint = firstSourceEndpoint;

	if (inList == false) {

		while (sourceEndpoint != 0) {
			destEndpoint = sourceEndpoint->firstDest;
			isDest = false;
		
			if (destEndpoint == 0) {
				lastRowItem = true;
			}
			else {
				lastRowItem = false;
			}

			while (lastRowItem == false) {

				if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, endpointId->name) == true) {
				// Endpoint is a RECEIVER/TRANCEIVER
					isDest = true;
					inList = true;
				}
				else {
					destEndpoint = destEndpoint->nextDest;

					if (destEndpoint == 0) {
						lastRowItem = true;
					}
				}

			} // End while, scanned through entire row of destinations

			sourceEndpoint = sourceEndpoint->nextSource;
		}; // End while, scanned through all columns of sources for all destinations
	
	}; // End if inList

	return(inList);
}; // END LINKTOPOLOGY::ISLINKENDPOINT_INSTALLED

bool LinkTopology::isNodeAttached(Identity_s *nodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, isNodeAttached\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inSourceList, inDestList, inList, lastRowItem;

	inList = inSourceList = false;

	sourceEndpoint = firstSourceEndpoint;

	// Scan to check whether node is attached to a source
	while (sourceEndpoint != 0 && inSourceList == false) {
		if (globalNameSpace->check_ifEqual(sourceEndpoint->nodeId.name, nodeId->name) == true) {
			// Endpoint is a TRANSMITTER/TRANCEIVER
			inList = inSourceList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	// Scan to check if node is listed among destinations (if not listed among sources)

	if (inSourceList == false) {
		sourceEndpoint = firstSourceEndpoint;

		while (sourceEndpoint != 0) {
			destEndpoint = sourceEndpoint->firstDest;
		
			if (destEndpoint == 0) {
				lastRowItem = true;
			}
			else {
				lastRowItem = false;
			}

			inDestList = false;

			while (lastRowItem == false && inDestList == false) {

				if (globalNameSpace->check_ifEqual(destEndpoint->nodeId.name, nodeId->name) == true) {
					inList = inDestList = true;
				}
				else {
					destEndpoint = destEndpoint->nextDest;

					if (destEndpoint == 0) {
						lastRowItem = true;
					}
				}

			} // End while, scanned through entire row of destinations

			sourceEndpoint = sourceEndpoint->nextSource;
		} // End while, scanned through all columns of sources for all destinations

	};  // ENDIF inSourceList

	return (inList);

}; // END LINKTOPOLOGY::ISNODEATTACHED

bool LinkTopology::isAnyNodeAttached() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, isAnyNodeAttached\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inSourceList, inDestList, inList, lastRowItem;

	inList = inSourceList = false;

	sourceEndpoint = firstSourceEndpoint;

	// Scan to check whether any node is attached to a source.
	while (sourceEndpoint != 0 && inSourceList == false) {
		if (globalNameSpace->check_ifValid(sourceEndpoint->nodeId.name) == true) {
			// Endpoint is a TRANSMITTER/TRANCEIVER
			inList = inSourceList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	// Scan to check if node is listed among destinations (if not listed among sources)

	if (inSourceList == false) {
		sourceEndpoint = firstSourceEndpoint;

		while (sourceEndpoint != 0) {
			destEndpoint = sourceEndpoint->firstDest;
		
			if (destEndpoint == 0) {
				lastRowItem = true;
			}
			else {
				lastRowItem = false;
			}

			inDestList = false;

			while (lastRowItem == false && inDestList == false) {

				if (globalNameSpace->check_ifValid(destEndpoint->nodeId.name) == true) {
					inList = inDestList = true;
				}
				else {
					destEndpoint = destEndpoint->nextDest;

					if (destEndpoint == 0) {
						lastRowItem = true;
					}
				}

			} // End while, scanned through entire row of destinations

			sourceEndpoint = sourceEndpoint->nextSource;
		} // End while, scanned through all columns of sources for all destinations

	};  // ENDIF inSourceList

	return (inList);

}; // END LINKTOPOLOGY::ISANYNODEATTACHED

int LinkTopology::add_linkEndpointInfo(LinkEndpoint *linkEndpoint, Identity_s *nodeId, Identity_s *interfaceId, CallbackProtocol *CALLBACK_functions) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, add_linkEndpointInfo\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inSourceList, inDestList, inList, lastRowItem;
	// It is assumed that it has been checked that the LinkEndpoint is in list
	// Add info in case it is a source

	inList = inSourceList = false;

	sourceEndpoint = firstSourceEndpoint;

	// Scan to check whether endpoint might be a source, and if yes, add node id
	while (sourceEndpoint != 0 && inList == false) {
		if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			sourceEndpoint->nodeId = *nodeId;
			sourceEndpoint->interfaceId = *interfaceId;
			// Endpoint is a TRANSMITTER/TRANCEIVER
			inList = inSourceList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	// Scan to check if endpoint is a destination, and if yes, add info for each occurrence of the destination
	sourceEndpoint = firstSourceEndpoint;

	while (sourceEndpoint != 0) {
		destEndpoint = sourceEndpoint->firstDest;
		
		if (destEndpoint == 0) {
			lastRowItem = true;
		}
		else {
			lastRowItem = false;
		}

		inDestList = false;

		while (lastRowItem == false && inDestList == false) {

			if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a RECEIVER/TRANCEIVER
				destEndpoint->nodeId = *nodeId;
				destEndpoint->superNodeId = identity.reset_anotherIdentity();
				destEndpoint->interfaceId = *interfaceId;
				destEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions = CALLBACK_functions;
				inList = inDestList = true;
			}
			else {
				destEndpoint = destEndpoint->nextDest;

				if (destEndpoint == 0) {
					lastRowItem = true;
				}
			}

		} // End while, scanned through entire row of destinations

		sourceEndpoint = sourceEndpoint->nextSource;
	} // End while, scanned through all columns of sources for all destinations

	if (inList == true) {
		return(0);
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(),"add_linkEndpointInfo","Invalid_linkEndpoint,_not_in_topology", SYS_ERR_HARD);
		return(-1);
	}

}; // END LINKTOPOLOGY::ADD_LINKENDPOINTINFO

int LinkTopology::add_linkEndpointInfo(LinkEndpoint *linkEndpoint, Identity_s *nodeId, Identity_s *interfaceId, CallbackInterface *CALLBACK_functions) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, add_linkEndpointInfo\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inSourceList, inDestList, inList, lastRowItem;
	// It is assumed that it has been checked that the LinkEndpoint is in list
	// Add info in case it is a source

	inList = inSourceList = false;

	sourceEndpoint = firstSourceEndpoint;

	// Scan to check whether endpoint might be a source, and if yes, add node id
	while (sourceEndpoint != 0 && inList == false) {
		if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			sourceEndpoint->nodeId = *nodeId;
			sourceEndpoint->interfaceId = *interfaceId;
			// Endpoint is a TRANSMITTER/TRANCEIVER
			inList = inSourceList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	// Scan to check if endpoint is a destination, and if yes, add info for each occurrence of the destination
	sourceEndpoint = firstSourceEndpoint;

	while (sourceEndpoint != 0) {
		destEndpoint = sourceEndpoint->firstDest;
		
		if (destEndpoint == 0) {
			lastRowItem = true;
		}
		else {
			lastRowItem = false;
		}

		inDestList = false;

		while (lastRowItem == false && inDestList == false) {

			if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a RECEIVER/TRANCEIVER
				destEndpoint->nodeId = *nodeId;
				destEndpoint->superNodeId = identity.reset_anotherIdentity();
				destEndpoint->interfaceId = *interfaceId;
				destEndpoint->CALLBACK_functions.CALLBACK_InfFunctions = CALLBACK_functions;
				inList = inDestList = true;
			}
			else {
				destEndpoint = destEndpoint->nextDest;

				if (destEndpoint == 0) {
					lastRowItem = true;
				}
			}

		} // End while, scanned through entire row of destinations

		sourceEndpoint = sourceEndpoint->nextSource;
	} // End while, scanned through all columns of sources for all destinations

	if (inList == true) {
		return(0);
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(),"add_linkEndpointInfo","Invalid_linkEndpoint,_not_in_topology", SYS_ERR_HARD);
		return(-1);
	}

}; // END LINKTOPOLOGY::ADD_LINKENDPOINTINFO

int LinkTopology::remove_linkEndpointInfo(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, remove_linkEndpointInfo\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inList, lastRowItem;
	// It is assumed that it has been checked that the LinkEndpoint is in list
	// Remove info in case it is a source

	inList = false;

	sourceEndpoint = firstSourceEndpoint;

	// Scan to check whether endpoint might be a source, and if yes, remove node id
	while (sourceEndpoint != 0 && inList == false) {

		if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			sourceEndpoint->nodeId = identity.reset_anotherIdentity();
			sourceEndpoint->interfaceId = identity.reset_anotherIdentity();
			// Endpoint is a TRANSMITTER/TRANCEIVER
			inList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	// Scan to check if endpoint is a destination, and if yes, remove all info for each occurrence of the destination
	sourceEndpoint = firstSourceEndpoint;

	while (sourceEndpoint != 0) {
		inList = false;
		destEndpoint = sourceEndpoint->firstDest;
		
		if (destEndpoint == 0) {
			lastRowItem = true;
		}
		else {
			lastRowItem = false;
		}

		while (lastRowItem == false && inList == false) {

			if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a RECEIVER/TRANCEIVER
				destEndpoint->nodeId = identity.reset_anotherIdentity();
				destEndpoint->superNodeId = identity.reset_anotherIdentity(); 
				destEndpoint->interfaceId = identity.reset_anotherIdentity();
				destEndpoint->CALLBACK_functions.CALLBACK_InfFunctions = 0;
				destEndpoint->CALLBACK_functions.CALLBACK_ProtFunctions = 0;
				inList = true;
			}
			else {
				destEndpoint = destEndpoint->nextDest;

				if (destEndpoint == 0) {
					lastRowItem = true;
				}
			}

		} // End while, scanned through entire row of destinations

		sourceEndpoint = sourceEndpoint->nextSource;
	} // End while, scanned through all columns of sources for all destinations

	if (inList == true) {
		return(0);
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(),"remove_linkEndpointInfo","Invalid_linkEndpoint,_not_in_topology", SYS_ERR_HARD);
		return(-1);
	}

}; // END LINKTOPOLOGY::REMOVE_LINKENDPOINTINFO

int LinkTopology::add_superNodeInfo(LinkEndpoint *linkEndpoint, Identity_s *superNodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, add_superNodeInfo\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inList, lastRowItem, destEndpointFound;
	// It is assumed that it has been checked that the LinkEndpoint is in list
	// Add info in case it is a source

	inList = destEndpointFound = false;

	// Scan to check if endpoint is a destination, and if yes, add info for each occurrence of the destination
	sourceEndpoint = firstSourceEndpoint;

	while (sourceEndpoint != 0) {
		destEndpoint = sourceEndpoint->firstDest;
		
		if (destEndpoint == 0) {
			lastRowItem = true;
		}
		else {
			lastRowItem = false;
		}

		while (lastRowItem == false && destEndpointFound == false) {

			if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a RECEIVER/TRANCEIVER
				destEndpointFound = true;
				destEndpoint->superNodeId = *superNodeId;
				inList = true;

//				string input;
//				cout << " destEndPoint: " << destEndpoint->nodeId.name.name << " " << destEndpoint->superNodeId.name.name << " " << destEndpoint->interfaceId.name.name << "\n";
//				cin >> input;

			}
			else {
				destEndpoint = destEndpoint->nextDest;

				if (destEndpoint == 0) {
					lastRowItem = true;
				}
			}

		} // End while, scanned through entire row of destinations

		destEndpointFound = false;
		sourceEndpoint = sourceEndpoint->nextSource;
	} // End while, scanned through all columns of sources for all destinations

	if (inList == true) {
		return(0);
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(),"add_superNodeInfo","Invalid_linkEndpoint,_not_in_topology", SYS_ERR_HARD);
		return(-1);
	}

}; // END LINKTOPOLOGY::ADD_SUPERNODEINFO


int LinkTopology::remove_superNodeInfo(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, remove_superNodeInfo\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpoint_s *destEndpoint;
	bool inList, lastRowItem;
	// It is assumed that it has been checked that the LinkEndpoint is in list
	// Remove info in case it is a source

	inList = false;

	// Scan to check if endpoint is a destination, and if yes, remove all info for each occurrence of the destination
	sourceEndpoint = firstSourceEndpoint;

	while (sourceEndpoint != 0) {
		destEndpoint = sourceEndpoint->firstDest;
		
		if (destEndpoint == 0) {
			lastRowItem = true;
		}
		else {
			lastRowItem = false;
		}

		while (lastRowItem == false && inList == false) {

			if (globalNameSpace->check_ifEqual(destEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a RECEIVER/TRANCEIVER
				destEndpoint->superNodeId = identity.reset_anotherIdentity();
				inList = true;
			}
			else {
				destEndpoint = destEndpoint->nextDest;

				if (destEndpoint == 0) {
					lastRowItem = true;
				}
			}

		} // End while, scanned through entire row of destinations

		sourceEndpoint = sourceEndpoint->nextSource;
	} // End while, scanned through all columns of sources for all destinations

	if (inList == true) {
		return(0);
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(),"remove_superNodeInfo","Invalid_linkEndpoint,_not_in_topology", SYS_ERR_HARD);
		return(-1);
	}

}; // END LINKTOPOLOGY::REMOVE_SUPERNODEINFO


LinkDestEndpointInfo_s LinkTopology::get_nextLinkDestEndpointInfo(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkTopology, get_nextLinkDestEndpointInfo\n");}

	LinkSourceEndpoint_s *sourceEndpoint;
	LinkDestEndpointInfo_s linkDestInfo;
	bool inList;

	// It is assumed that it has been checked that the LinkEndpoint is in list
	// Remove info in case it is a source

	inList = false;

	sourceEndpoint = firstSourceEndpoint;

	linkDestInfo.nodeId = identity.reset_anotherIdentity();
	linkDestInfo.nodeInfId = identity.reset_anotherIdentity();
	linkDestInfo.superNodeId = identity.reset_anotherIdentity();
	linkDestInfo.CALLBACK_functions.CALLBACK_InfFunctions = 0;
	linkDestInfo.CALLBACK_functions.CALLBACK_ProtFunctions = 0;

	// Scan to check whether endpoint is a source, and if found return next destination.
	while (sourceEndpoint != 0 && inList == false) {

		if (globalNameSpace->check_ifEqual(sourceEndpoint->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			// Endpoint is a TRANSMITTER/TRANCEIVER
			if (nextDestEndpoint == 0) {
				nextDestEndpoint = sourceEndpoint->firstDest;
			}
			else {
				nextDestEndpoint = nextDestEndpoint->nextDest;
			}

			if (nextDestEndpoint != 0) {
				linkDestInfo.nodeId = nextDestEndpoint->nodeId;
				linkDestInfo.superNodeId = nextDestEndpoint->superNodeId;
				linkDestInfo.nodeInfId = nextDestEndpoint->interfaceId;
				linkDestInfo.CALLBACK_functions = nextDestEndpoint->CALLBACK_functions;
			}

			inList = true;
		}
		else {
			sourceEndpoint = sourceEndpoint->nextSource;
		}
	} // End while (scanned through column of sources)

	if (inList == false) {
		SYSTEM->runtimerror(&identity.get_identity(),"get_nextLinkDestEndpointInfo","Linkendpoint_not_a_source", SYS_ERR_HARD);
	};
	
	return(linkDestInfo);

}; // END LINKTOPOLOGY::GET_NEXTLINKDESTENDPOINTINFO

// CLASS LINK FUNCTIONS
void Link::Link_init(Identity_s *id, bool coreLink, LinkTraits_s linkTraits, unsigned int ttl, Identity_s *liveKeeper) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, init\n");}

	Identity_s linkTopologyId, transmissionId;

	firstLinkEndpoint = nextLinkEndpoint = 0;
	currentNumberLinkEndpoints = 0;
	linkTopologyId.type = "LINKTOPOLOGY";
	linkTopologyId.nickName = "-";
	Entity_init(id, ttl, liveKeeper);
	linkTopology.LinkTopology_init(&linkTopologyId);
	myLinkInfo.linkId = *id;
	myLinkInfo.coreLink = coreLink;
	myLinkInfo.linkTraits = linkTraits;
	transmissionId.type = "TRANSMISSIONRES";
	transmissionId.nickName = "-";
	transmission.TransmissionRes_init(&transmissionId, myLinkInfo.linkTraits.transmission, myLinkInfo.linkTraits.genTransmission);
};

void Link::Link_delete() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, delete\n");}
	// Deletes all dynamic memory, i.e. all endpoints and associated structs
	LinkEndpointList_s *linkEndp, *nextLinkEndp, *oldLinkEndp;

	linkEndp = nextLinkEndp = firstLinkEndpoint;
	
	while (linkEndp != 0) {
		linkTopology.remove_linkEndpoint(linkEndp->linkEndpoint);
		linkEndp->linkEndpoint->LinkEndpoint_delete();
		delete linkEndp->linkEndpoint;
		oldLinkEndp = linkEndp;
		linkEndp = linkEndp->nextLinkEndpoint;
		delete oldLinkEndp;
	};

	this->Entity_delete();
};

int Link::add_linkEndpoint(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, add_linkEndpoint\n");}

	LinkEndpointList_s *linkEndp, *lastLinkEndp, *newLinkEndp;
	bool inList, nameEqual;
	Identity_s id;

	// Check it has not been installed
	if (currentNumberLinkEndpoints < myLinkInfo.linkTraits.maxLinkEndpoints) {
		linkEndp = firstLinkEndpoint;
		lastLinkEndp = firstLinkEndpoint;
		inList = false;

		while (linkEndp != 0 && inList == false ) {
			nameEqual = globalNameSpace->check_ifEqual(linkEndp->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name);

			if (nameEqual == true) {
				inList = true;
			}

			lastLinkEndp = linkEndp;
			linkEndp = linkEndp->nextLinkEndpoint;
		};

		if (inList == false) {

			try {
				newLinkEndp = new LinkEndpointList_s;
			} catch (bad_alloc xa) {
				SYSTEM->runtimerror(&get_identity(), "add_linkEndpoint","allocation_failure", SYS_ERR_HARD);
				return(-1);
			}

			if (lastLinkEndp != 0) {
				lastLinkEndp->nextLinkEndpoint = newLinkEndp;
				newLinkEndp->previousLinkEndpoint = lastLinkEndp;
				newLinkEndp->nextLinkEndpoint = 0;
				newLinkEndp->linkEndpoint = linkEndpoint;
				newLinkEndp->attached = false;
			}
			else {
				firstLinkEndpoint = newLinkEndp;
				nextLinkEndpoint = firstLinkEndpoint;
				firstLinkEndpoint->linkEndpoint = linkEndpoint;
				firstLinkEndpoint->attached = false;
				firstLinkEndpoint->previousLinkEndpoint = firstLinkEndpoint->nextLinkEndpoint = 0;
			};

			linkTopology.add_linkEndpoint(linkEndpoint);
			currentNumberLinkEndpoints++;
			return(0);
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "add_linkEndpoint","link_endpoint_already_installed", SYS_ERR_HARD);
			return(-1);
		};

	}
	else {
		cout << "\nMax linkendpoints reached: " << this->myLinkInfo.linkTraits.maxLinkEndpoints << "\n";
		SYSTEM->runtimerror(&get_identity(), "add_linkEndpoint","exceeding_max_number_of_link_endpoints", SYS_ERR_HARD);
		return(-1);
	};

};

int Link::remove_linkEndpoint(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, remove_linkEndpoint\n");}

	LinkEndpointList_s *linkEndp;
	bool inList;

	// Check it has been installed
	linkEndp = firstLinkEndpoint;
	inList = false;

	while (linkEndp != 0 && inList == false ) {

		if (globalNameSpace->check_ifEqual(linkEndp->linkEndpoint->get_identity().name, linkEndpoint->get_identity().name) == true) {
			inList = true;
		}
		else {
			linkEndp = linkEndp->nextLinkEndpoint;
		};

	};

	if (inList == true && linkEndp->attached == false) {  // A link endpoint which is attached to a node can't be removed

		if (linkEndp == firstLinkEndpoint) {
			firstLinkEndpoint = firstLinkEndpoint->nextLinkEndpoint;

			if (firstLinkEndpoint != 0) {
				linkEndp->previousLinkEndpoint = 0;
			}

		}
		else if (linkEndp->nextLinkEndpoint == 0) {  // Last LinkEndpoint
			linkEndp->previousLinkEndpoint->nextLinkEndpoint = 0;
		}
		else {
			linkEndp->previousLinkEndpoint->nextLinkEndpoint = linkEndp->nextLinkEndpoint;
			linkEndp->nextLinkEndpoint->previousLinkEndpoint = linkEndp->previousLinkEndpoint;
		};

		linkTopology.remove_linkEndpoint(linkEndpoint);  // Will also remove any info associated to the linkendpoint
		currentNumberLinkEndpoints--;
		delete linkEndp;

		if (currentNumberLinkEndpoints == 0) {
			firstLinkEndpoint = nextLinkEndpoint = 0;
		}

		return(0);
	}
	else {
		SYSTEM->runtimerror(&this->get_identity(), "remove_linkEndpoint", "Link_endpoint_doesn't_exist_OR_is_still_attached_to_node", SYS_ERR_HARD);
		return(-1);
	};

};

int Link::get_currentNumberLinkEndpoints() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, get_currentNumberLinkEndpoints\n");}
	return(currentNumberLinkEndpoints);
};

bool Link::isLinkEndpoint_installed(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, isLinkEndpoint_installed\n");}
	return(linkTopology.isLinkEndpoint_installed(linkEndpoint));
};


bool Link::isNodeAttached(Identity_s *nodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, isNodeAttached\n");}
	return(linkTopology.isNodeAttached(nodeId));
};

bool Link::isAnyNodeAttached() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, isAnyNodeAttached\n");}
	return(linkTopology.isAnyNodeAttached());
};

float Link::get_linkLength() { 	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, get_linkLength\n");} return(myLinkInfo.linkTraits.length); };

LinkTraits_s Link::get_linkTraits() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, get_linkTraits\n");}
	return(myLinkInfo.linkTraits);
};

LinkInfo_s *Link::get_myLinkInfo() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, get_myLinkInfo\n");}
	return(&myLinkInfo);
};
int Link::attach_node(Identity_s *nodeId, Identity_s *interfaceId, LinkEndpoint *linkEndpoint, CallbackProtocol *CALLBACK_functions) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, attach_node\n");}
	LinkEndpointList_s *linkEndpointItem;

	linkEndpointItem = this->find_linkEndpointItem(&linkEndpoint->get_identity());

	if (linkEndpointItem != 0 && linkEndpointItem->attached == false) {
		linkTopology.add_linkEndpointInfo(linkEndpoint, nodeId, interfaceId, CALLBACK_functions);
		linkEndpointItem->attached = true;
		return(0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(),"attach_node","endpoint_not_installed_OR_already_attached_to_a_node", SYS_ERR_HARD);
		return(-1);
	};

};

int Link::attach_node(Identity_s *nodeId, Identity_s *interfaceId, LinkEndpoint *linkEndpoint, CallbackInterface *CALLBACK_functions) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, attach_node\n");}
	LinkEndpointList_s *linkEndpointItem;

	linkEndpointItem = this->find_linkEndpointItem(&linkEndpoint->get_identity());

	if (linkEndpointItem != 0 && linkEndpointItem->attached == false) {
		linkTopology.add_linkEndpointInfo(linkEndpoint, nodeId, interfaceId, CALLBACK_functions);
		linkEndpointItem->attached = true;
		return(0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(),"attach_node","endpoint_not_installed_OR_already_attached_to_a_node", SYS_ERR_HARD);
		return(-1);
	};

};

int Link::detach_node(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, detach_node\n");}
	LinkEndpointList_s *linkEndpointItem;

	linkEndpointItem = this->find_linkEndpointItem(&linkEndpoint->get_identity());

	if (linkEndpointItem != 0 && linkEndpointItem->attached == true) {
		linkTopology.remove_linkEndpointInfo(linkEndpoint);
		linkEndpointItem->attached = false;
		return(0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(),"detach_node","endpoint_not_installed", SYS_ERR_HARD);
		return(-1);
	};

};

int Link::attach_superNode(Identity_s *superNodeId, LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, attach_superNode\n");}
	
	if (linkTopology.add_superNodeInfo(linkEndpoint, superNodeId) != 0) {
		return (-1);
	}
	else {
		return(0);
	}

};

int Link::remove_superNode(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, remove_superNode\n");}
	
	if (linkTopology.remove_superNodeInfo(linkEndpoint) != 0) {
		return(-1);
	}
	else {
		return(0);
	}

};

LinkEndpoint *Link::get_nextLinkEndpoint(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, get_nextLinkEndpoint\n");}
	LinkEndpointList_s *currentLinkEndpoint;
	
	if (nextLinkEndpoint == 0 || reset == true) {
		nextLinkEndpoint = firstLinkEndpoint;
		return(0);
	}
	else {
		currentLinkEndpoint = nextLinkEndpoint;
		nextLinkEndpoint = nextLinkEndpoint->nextLinkEndpoint;
		return(currentLinkEndpoint->linkEndpoint);
	};

};

LinkDestEndpointInfo_s Link::get_nextLinkEndpointInfo(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, get_nextLinkEndpointInfo\n");}
	return(linkTopology.get_nextLinkDestEndpointInfo(linkEndpoint));
};

bool Link::isLinkEndpoint_attached(LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, isLinkEndpoint_attached\n");}
	LinkEndpointList_s *linkEndpointItem;

	linkEndpointItem = this->find_linkEndpointItem(&linkEndpoint->get_identity());

	if (linkEndpointItem != 0) {
		return(linkEndpointItem->attached);
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "isLinkEndpoint_attached", "Link_endpoint_doesn't_exist", SYS_ERR_HARD);
		return(false);
	};

};

LinkEndpointList_s *Link::find_linkEndpointItem(Identity_s *linkEndpointId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Link, find_linkEndpointItem\n");}
	LinkEndpointList_s *linkEndpoint;
	bool linkEndpointFound;

	linkEndpoint = firstLinkEndpoint;
	linkEndpointFound = false;

	while (linkEndpoint != 0 && linkEndpointFound == false) {

		if (globalNameSpace->check_ifEqual(linkEndpoint->linkEndpoint->get_identity().name, linkEndpointId->name) == true) {
			linkEndpointFound = true;
		}
		else {
			linkEndpoint = linkEndpoint->nextLinkEndpoint;
		};

	};

	return(linkEndpoint);
};

void Link::CALLBACK_tickZero(void * parameters, int secret) {  // This function is not in use
};
ostream &operator<<(ostream &stream, Link *li) {
	Entity *enp;
	int numberLinkEndpoints, numberInstances;
	Identity_s id, idNext;
	LinkEndpointList_s *lepRef, *lepRefNext;
	bool otherTypeFound;

	enp = li;
	stream << "Link_Status: " << enp;

	stream << " External name: " << SYSTEM->find_linkExtName(&li->get_identity()) << " ";
	stream << "Current number link endpoints: " << li->currentNumberLinkEndpoints << "\n";

	if (li->currentNumberLinkEndpoints > 0) {
		stream << "Link endpoint types:\n";

		numberLinkEndpoints = li->currentNumberLinkEndpoints;
		lepRef = li->firstLinkEndpoint;

		while (numberLinkEndpoints > 0) {
			lepRefNext = lepRef;
			id = lepRefNext->linkEndpoint->get_identity();
			numberInstances = 1;
			numberLinkEndpoints--;

			// Find all other occurences of this link endpoint type
			otherTypeFound = false;

			while (lepRefNext != 0) {
				lepRefNext = lepRefNext->nextLinkEndpoint;

				if (lepRefNext != 0) {
					idNext = lepRefNext->linkEndpoint->get_identity();

					if (idNext.type != id.type && otherTypeFound == false) {
						lepRef = lepRefNext;
						otherTypeFound = true;
					}
					else {
						numberInstances++;
						numberLinkEndpoints--;
					};

				};

			};  // ENDWHILE lepRefNext

			stream << "  Type: " << id.type << " Nickname: " << id.nickName << " Number of instances: " << numberInstances << "\n";

		};  // ENDWHILE numberLinkEndpoints

	}; // ENDIF currentNumberLinkEndpoints

	stream << "End_LinkStatus\n";
	return stream;
};
