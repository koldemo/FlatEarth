#include <iostream>
#include <string>
#include <new>
using namespace std;

#include "C:\Users\CLONEZILLA\Documents\Visual Studio 2008\Projects\Netcell_test\Netcell_test\definitions.h"

// CLASS SWITCHCORE FUNCTIONS
void SwitchCore::SwitchCore_init(Identity_s *id, SwitchCoreTraits_s switchCoreTraits, Node *nodeRef, unsigned int ttl) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, init\n");}
	Identity_s switchingId;

	maxInf = switchCoreTraits.maxInf;
	currentNumberInf = 0;
	ownNodeRef = nodeRef;
	firstSwitchInfItem = 0;
	firstIntLinkItem  = 0;
	Entity_init(id, ttl, 0);

	switchingId.type = "SWITCHRES";
	switchingId.nickName = "-";
	switching.SwitchCoreRes_init(&switchingId, switchCoreTraits.switching, switchCoreTraits.genSwitching);
	switchCoreTicks = SYSTEM->msToTick(SWITCHCORE_BACKGROUND_POLL);
	
	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(switchCoreTicks), CB_SWITCHCORE, 0);
};

void SwitchCore::SwitchCore_delete() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, delete\n");}

	SwitchCoreInf_s *swCoreInf, *oldSwCoreInf;
	InternalLinkListItem_s *intLinkItem, *oldIntLinkItem;
	SwitchCoreInfItem_s *swCoreInfItem, *oldSwCoreInfItem;
	SwitchCNodeInfItem_s *swCNodeInfItem, *oldSwCNodeInfItem;

	swCoreInf = firstSwitchInfItem;

	while (swCoreInf != 0) {
		oldSwCoreInf = swCoreInf;
		swCoreInf = swCoreInf->nextSwitchInf;
		oldSwCoreInf->switchInf->SwitchCoreInterface_delete();
		delete oldSwCoreInf;
	}

	intLinkItem = firstIntLinkItem;

	while (intLinkItem != 0) {
		oldIntLinkItem = intLinkItem;

		swCoreInfItem = oldIntLinkItem->firstSwitchCoreInfItem;
		swCNodeInfItem = oldIntLinkItem->firstNodeInfItem;

		while (swCoreInfItem != 0) {
			oldSwCoreInfItem = swCoreInfItem;
			oldSwCoreInfItem->switchCoreInf->SwitchCoreInterface_delete();
			delete oldSwCoreInfItem->switchCoreInf;
			swCoreInfItem = swCoreInfItem->nextItem;
			delete oldSwCoreInfItem;
		}

		while (swCNodeInfItem != 0) {
			oldSwCNodeInfItem = swCNodeInfItem;
			// The node interface is not deleted!!!
			swCNodeInfItem = swCNodeInfItem->nextItem;
			delete oldSwCNodeInfItem;
		};

		oldIntLinkItem->internalLink->Link_delete();
		delete oldIntLinkItem->internalLink;
		intLinkItem = intLinkItem->nextItem;
		delete oldIntLinkItem;
	};

	if (callbackRef != -1) {
		SYSTEM->delete_ticksQueueEvent(callbackRef);
		callbackRef = -1;
		cout << "SwitchCore Callback\n"; 
	}

	this->Entity_delete();
};


int SwitchCore::install_switchInf(SwitchCoreInterface *switchInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, install_switchInf\n");}

	SwitchCoreInf_s *newSwitchInfItem, *switchInfItem;

	if (currentNumberInf < maxInf) {

		try {
			newSwitchInfItem = new SwitchCoreInf_s;
		} catch (bad_alloc xa) {
			SYSTEM->runtimerror(&get_identity(), "install_switchInf","allocation_failure", SYS_ERR_HARD);
			return(-1);
		}

	}
	else {
		SYSTEM->runtimerror(&get_identity(), "install_switchInf","max_number_of_interfaces_has_been_installed", SYS_ERR_HARD);
		return(-1);
	};

	// Find last position of SwitchCoreInf_s array
	if (firstSwitchInfItem == 0) {
		firstSwitchInfItem = newSwitchInfItem;
		firstSwitchInfItem->switchInf = switchInf;
		firstSwitchInfItem->previousSwitchInf = firstSwitchInfItem->nextSwitchInf = 0;
	}
	else {
		switchInfItem = firstSwitchInfItem;

		while (switchInfItem->nextSwitchInf != 0) {
			switchInfItem = switchInfItem->nextSwitchInf;
		};

		switchInfItem->nextSwitchInf = newSwitchInfItem;
		newSwitchInfItem->switchInf = switchInf;
		newSwitchInfItem->previousSwitchInf = switchInfItem;
		newSwitchInfItem->nextSwitchInf = 0;
	};

	currentNumberInf++;

	return(0);
};

int SwitchCore::uninstall_switchInf(SwitchCoreInterface *switchInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, uninstall_switchInf\n");}

	SwitchCoreInf_s *oldSwitchInfItem, *switchInfItem;
	bool inList;

	// Find last position of SwitchCoreInf_s array
	if (currentNumberInf > 0) {
		switchInfItem = firstSwitchInfItem;
		inList = false;

		while (switchInfItem != 0 && inList == false) {

			if (globalNameSpace->check_ifEqual(switchInfItem->switchInf->get_identity().name, switchInf->get_identity().name) == true) {
				inList = true;
				oldSwitchInfItem = switchInfItem;
			};

			switchInfItem = switchInfItem->nextSwitchInf;
		};

		if (inList == true) {

			if (oldSwitchInfItem == firstSwitchInfItem) {
				firstSwitchInfItem = oldSwitchInfItem->nextSwitchInf;

				if (firstSwitchInfItem != 0) {
					firstSwitchInfItem->previousSwitchInf = 0;
				}
			}
			else if (oldSwitchInfItem->nextSwitchInf == 0) {  // Last item
				oldSwitchInfItem->previousSwitchInf->nextSwitchInf = 0;
			}
			else {
				oldSwitchInfItem->previousSwitchInf->nextSwitchInf = oldSwitchInfItem->nextSwitchInf;
				oldSwitchInfItem->nextSwitchInf->previousSwitchInf = oldSwitchInfItem->previousSwitchInf;
			};

			delete oldSwitchInfItem;
			currentNumberInf--;
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "uninstall_switchInf","switchcore_interface_not_installed", SYS_ERR_HARD);
			return(-1);
		};

	}
	else {
		SYSTEM->runtimerror(&get_identity(), "uninstall_switchInf","switchcore_interface_list_is_already_empty", SYS_ERR_HARD);
		return(-1);
	};

	return(0);
};

bool SwitchCore::isSwitchInf_installed(SwitchCoreInterface *switchInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, isSwitchInf_installed\n");}

	SwitchCoreInf_s *switchInfItem;
	bool inList;

	switchInfItem = firstSwitchInfItem;
	inList = false;

	while (switchInfItem != 0 && inList == false) {;

		if (globalNameSpace->check_ifEqual(switchInfItem->switchInf->get_identity().name, switchInf->get_identity().name) == true) {
			inList = true;
		}
		else {
			switchInfItem = switchInfItem->nextSwitchInf;
		};

	};

	return(inList);
};

SwitchCoreInterface *SwitchCore::find_switchInf(Link *intLink) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, find_switchInf\n");}

	SwitchCoreInf_s *switchInfItem;
	AttachedLink_s attachedLink;
	bool inList;

	switchInfItem = firstSwitchInfItem;
	inList = false;

	while (switchInfItem != 0 && inList == false) {

		attachedLink = switchInfItem->switchInf->isLinkAttached();

		if (globalNameSpace->check_ifEqual(attachedLink.link->get_identity().name, intLink->get_identity().name) == true) {
			inList = true;
		}
		else {
			switchInfItem = switchInfItem->nextSwitchInf;
		};

	};

	return(switchInfItem->switchInf);
};

int SwitchCore::attach_link(SwitchCoreInterface *switchInf, Link *link, LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, attach_link\n");}

	if (isSwitchInf_installed(switchInf) == true) {

		if (switchInf->isLinkAttached(link) == false) {
			switchInf->attach_link(link, linkEndpoint);
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "attach_link","link_is_already_attached", SYS_ERR_HARD);
			return(-1);
		};

	}
	else {
		SYSTEM->runtimerror(&get_identity(), "attach_link","switchcore_interface_not_installed", SYS_ERR_HARD);
		return(-1);
	};

	return(0);
};

int SwitchCore::detach_link(SwitchCoreInterface *switchInf, Link *link) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, detach_link\n");}

	if (isSwitchInf_installed(switchInf) == true) {

		if (switchInf->isLinkAttached(link) == true) {
			switchInf->detach_link(link);
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "detach_link","link_has_already_been_detached", SYS_ERR_HARD);
			return(-1);
		};

	}
	else {
		SYSTEM->runtimerror(&get_identity(), "detach_link","switchcore_interface_not_installed", SYS_ERR_HARD);
		return(-1);
	};

	return(0);
};

int SwitchCore::get_currentNumberSwitchInf() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, get_currentNumberSwitchInf\n");}
	return(currentNumberInf);
};

SwitchCoreTraits_s SwitchCore::get_switchCoreTraits() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, get_switchCoreTraits\n");}

	SwitchCoreTraits_s traits;

	traits.maxInf = maxInf;
	traits.switching = switching.get_traits();
	traits.genSwitching = switching.get_genericTraits();

	return(traits);
};

InternalLinkListItem_s *SwitchCore::createNewSwitchInf(NodeInterface *nodeInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, createNewSwitchInf\n");}

	SwitchCoreInterface *newSwitchInf;
	SwitchCoreInterfaceTraits_s switchInfTraits;
	Link *newIntLink;
	LinkTraits_s newIntLinkTraits;
	LinkEndpoint *switchInfEndpoint, *nodeInfEndpoint;
	LinkEndpointTraits_s switchInfEndpointTraits, nodeInfEndpointTraits;
	InternalLinkListItem_s *newIntLinkItem;
	SwitchCoreInfItem_s *newSwitchCInfItem;
	SwitchCNodeInfItem_s *newSwitchCNodeInfItem;
	Identity_s switchInf_id, newIntLink_id, switchInfEndpoint_id, nodeInfEndpoint_id;
	bool allocFailure;
	unsigned int ttl;

	allocFailure = false;

	try {
		newSwitchInf = new SwitchCoreInterface;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&get_identity(), "createNewSwitchInf","allocation_failure", SYS_ERR_HARD);
		allocFailure = true;
	}

	if (allocFailure == false) {
		switchInf_id.type = "SWITCHCOREINTERFACE";
		switchInf_id.nickName = "-";
		switchInfTraits.genInfTraits.completionTime = switchInfTraits.genInfTraits.mtbf = 0;
		switchInfTraits.switchCoreInfTraits.queueRxLength = switchInfTraits.switchCoreInfTraits.queueTxLength = MAX_PDUQUEUE_LENGTH;  // Should be prgrammable!!!
	
		if (this->get_timeToLive().tickPoint == 0) {
			ttl = 0;
		}
		else {
			ttl = SYSTEM->ticksToMs(SYSTEM->subTicks(this->get_timeToLive(), SYSTEM->getTicks()));
		};

		newSwitchInf->SwitchCoreInterface_init(&switchInf_id, INF_SWITCHCORE, this, ownNodeRef->get_myNodeInfo(), switchInfTraits, ttl);
		this->install_switchInf(newSwitchInf);
	}

	try {
		newIntLink = new Link;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&get_identity(), "createNewSwitchInf","allocation_failure", SYS_ERR_HARD);
		allocFailure = true;
	}

	try {
		switchInfEndpoint = new LinkEndpoint;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&get_identity(), "createNewSwitchInf","allocation_failure", SYS_ERR_HARD);
		allocFailure = true;
	}

	try {
		nodeInfEndpoint = new LinkEndpoint;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&get_identity(), "createNewSwitchInf","allocation_failure", SYS_ERR_HARD);
		allocFailure = true;
	}

	if (allocFailure == false) {
		newIntLink_id.type = "LINK";
		newIntLink_id.nickName = "-";
		newIntLinkTraits.maxLinkEndpoints = 2;  // Only point-to-point supported!!!
		newIntLinkTraits.genTransmission.completionTime = 0;
		newIntLinkTraits.genTransmission.mtbf = 0;
		newIntLinkTraits.length = 0;
		newIntLinkTraits.transmission.bandwidth = 0;
		newIntLinkTraits.transmission.ber = 0;
		newIntLink->Link_init(&newIntLink_id, "-", newIntLinkTraits, 0, 0);

		switchInfEndpoint_id.type = "LINKENDPOINT";
		switchInfEndpoint_id.nickName = "-";
		switchInfEndpointTraits.genTraits.completionTime = 0;
		switchInfEndpointTraits.genTraits.mtbf = 0;
		switchInfEndpointTraits.attPointTraits.flowdir = TRANCEIVER;
		switchInfEndpointTraits.attPointTraits.beacon = false;
		switchInfEndpoint->LinkEndpoint_init(&switchInfEndpoint_id, switchInfEndpointTraits, 0);

		nodeInfEndpoint_id.type = "LINKENDPOINT";
		nodeInfEndpoint_id.nickName = "-";
		nodeInfEndpointTraits.genTraits.completionTime = 0;
		nodeInfEndpointTraits.genTraits.mtbf = 0;
		nodeInfEndpointTraits.attPointTraits.flowdir = TRANCEIVER;
		nodeInfEndpointTraits.attPointTraits.beacon = false;
		nodeInfEndpoint->LinkEndpoint_init(&nodeInfEndpoint_id, nodeInfEndpointTraits, 0);
		
		newIntLink->add_linkEndpoint(switchInfEndpoint);
		newIntLink->add_linkEndpoint(nodeInfEndpoint);
		ownNodeRef->attach_intLink(nodeInf, newSwitchInf, newIntLink, nodeInfEndpoint, switchInfEndpoint);
	};

	try {
		newIntLinkItem = new InternalLinkListItem_s;
		newSwitchCInfItem = new SwitchCoreInfItem_s;
		newSwitchCNodeInfItem = new SwitchCNodeInfItem_s;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&get_identity(), "createNewSwitchInf","allocation_failure", SYS_ERR_HARD);
		allocFailure = true;
	}

	if (allocFailure == false) {
		newSwitchCInfItem->switchCoreInf = newSwitchInf;
		newSwitchCInfItem->linkEndpoint = switchInfEndpoint;
		newSwitchCInfItem->previousItem = newSwitchCInfItem->nextItem = 0;
		newSwitchCNodeInfItem->nodeInf = nodeInf;
		newSwitchCNodeInfItem->linkEndpoint = nodeInfEndpoint;
		newSwitchCNodeInfItem->previousItem = newSwitchCNodeInfItem->nextItem = 0;
		newIntLinkItem->firstSwitchCoreInfItem = newSwitchCInfItem;
		newIntLinkItem->firstNodeInfItem = newSwitchCNodeInfItem;
		newIntLinkItem->internalLink = newIntLink;
		newIntLinkItem->previousItem = newIntLinkItem->nextItem = 0;
	}
	else {
		newIntLinkItem = 0;
	};

	return (newIntLinkItem);
};

void SwitchCore::CALLBACK_tickZero(void *parameters, int secret) {
	if (SYS_threadTrace== true) { SYSTEM->threadTrace(&get_identity(), &this->ownNodeRef->get_identity());}

	CALLBACK_update_switchCore();

	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(switchCoreTicks), CB_SWITCHCORE, 0);
};

void SwitchCore::CALLBACK_update_switchCore() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("SwitchCore, CALLBACK_update_switchCore\n");}
	
	NodeInterface *nodeInf;
	SwitchCoreInterface *switchInf;
	SwitchCoreInf_s *switchInfItem, *nextSwitchInfItem;
	AttachedLink_s intLink;
	// At the moment this function checks status of switchCore interfaces and links and see if they should be deleted/created.
	// At the moment, there is one switchcore interface per node interface.

	// Check for each external node interface whether an internal link exists
	nodeInf = ownNodeRef->getNext_nodeInterface(false);

	while (nodeInf != 0) {
		intLink = nodeInf->isIntLinkAttached();

		if (intLink.link == 0) {
			// Create a new switch core interface and a new internal link
			createNewSwitchInf(nodeInf);
		}

		nodeInf = ownNodeRef->getNext_nodeInterface(false);
	};

	// Remove switch interfaces and internal links for which there are no corresponding node interfaces
	switchInfItem = firstSwitchInfItem;

	while (switchInfItem != 0) {
		intLink = switchInfItem->switchInf->isLinkAttached();

		if (intLink.link->get_currentNumberLinkEndpoints() == 1) {  // This means only the endpoint for the switchCore interface is still existing.
			// Remove this switchCore interface and the link
			ownNodeRef->detach_intLink(0, switchInfItem->switchInf, intLink.link);
			switchInf = switchInfItem->switchInf;
			nextSwitchInfItem = switchInfItem->nextSwitchInf;
			this->uninstall_switchInf(switchInfItem->switchInf);
			switchInf->SwitchCoreInterface_delete();  // Link endpoint deleted as part of deleting the interface
			intLink.link->Link_delete();
			delete intLink.link;
			delete switchInf;
			switchInfItem = nextSwitchInfItem;
		}
		else {
			switchInfItem = switchInfItem->nextSwitchInf;
		};

	};  // ENDWHILE switchInfItem
		
};

ostream &operator<<(ostream &stream, SwitchCore *sc) {
	Entity *enp;
	Identity_s id;
	InternalLinkListItem_s *intLinkItem;
	SwitchCoreInfItem_s *switchCoreInfItem;
	SwitchCNodeInfItem_s *nodeInfItem;

	enp = sc;
	intLinkItem = sc->firstIntLinkItem;

	stream << "SwitchCore_Status: " << enp;
	stream << "Current number switchcore interfaces: " << sc->currentNumberInf << "\n";

	while (intLinkItem != 0) {
		id = intLinkItem->internalLink->get_identity();
		stream << "Internal link: " << id.type << " / " << id.nickName << " / " << id.name.name << "\n";
		stream << "Connected to switchcore interfaces:\n ";
		switchCoreInfItem = intLinkItem->firstSwitchCoreInfItem;

		while (switchCoreInfItem != 0) {
			id = switchCoreInfItem->switchCoreInf->get_identity();
			stream << id.type << " / " << id.nickName << " / " << id.name.name;
			switchCoreInfItem = switchCoreInfItem->nextItem;
		};

		stream << "\n Connected to node interfaces: ";
		nodeInfItem = intLinkItem->firstNodeInfItem;

		while (nodeInfItem != 0) {
			id = nodeInfItem->nodeInf->get_identity();
			stream << id.type << " / " << id.nickName << " / " << id.name.name;
			nodeInfItem = nodeInfItem->nextItem;
		};

		stream << "\n";
		intLinkItem = intLinkItem->nextItem;
	};

	stream << "End_SwitchCore_Status\n";
	return stream;
};

// CLASS NODE FUNCTIONS
void Node::Node_init(Identity_s *id, int domainRadius, Node *centroidNode, NodeTraits_s nodeTraits, NodeCoordinates_s coord, unsigned int ttl, Identity_s *liveKeeper) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, init\n");}

	Identity_s switchCoreId, nodeTopologyId, remoteTopologyId, sortedTopologyId, centroidId, linkAbstractionId, processorResId, memoryResId;
	int i;

	Entity_init(id, ttl, liveKeeper);
	currentNoInterfaces = 0;
	myNodeInfo.domainRadius = domainRadius;
	myNodeInfo.nodeId = get_identity();
	myNodeInfo.domainCenter = false;
	myNodeInfo.nodeTraits.domainLevel = nodeTraits.domainLevel;
	myNodeInfo.nodeTraits.maxInf = nodeTraits.maxInf;
	myNodeInfo.nodeTraits.genMemory = nodeTraits.genMemory;
	myNodeInfo.nodeTraits.genProcessing = nodeTraits.genProcessing;
	myNodeInfo.nodeTraits.memory = nodeTraits.memory;
	myNodeInfo.nodeTraits.processing = nodeTraits.processing;
	myNodeInfo.nodeTraits.switchCore = nodeTraits.switchCore;
	currentPos = coord;

	if (centroidNode == 0) {  // This is the centroidNode of a possible underlying topology!!!
		myNodeInfo.coreNode = true; // Without knowledge of core node status, it is assumed the node is a core node, i.e. a node that doesn't have internal interfaces.
		subNode = 0;
	}
	else {
		myNodeInfo.coreNode = false;
		subNode = centroidNode;
	};

	switchCoreId.type = "SWITCHCORE";
	switchCoreId.nickName = "-";
	switchCore.SwitchCore_init(&switchCoreId, myNodeInfo.nodeTraits.switchCore, this, 0);
	nodeTopologyId.type = "NODETOPOLOGY";
	nodeTopologyId.nickName = "-";
	nodeTopology.NodeTopology_init(&nodeTopologyId, this);
	remoteTopologyId.type = "REMOTENODETOPOLOGY";
	remoteTopologyId.nickName = "-";
	remoteExtNodeTopology.RemoteNodeTopology_init(&remoteTopologyId, this, &nodeTopology);
	sortedTopologyId.type = "SORTEDTOPOLOGY";
	sortedTopologyId.nickName = "-";
	sortedTopology.SortedTopology_init(&sortedTopologyId, this, &remoteExtNodeTopology);
	centroidId.type = "CENTROID";
	centroidId.nickName = "-";
	centroid.Centroid_init(&centroidId, this, &sortedTopology, &remoteExtNodeTopology, &nodeTopology, myNodeInfo.domainRadius);

	if (myNodeInfo.coreNode == false) {  // LinkAbstraction only need to run for superNodes
		linkAbstractionId.type = "LINKABSTRACTION";
		linkAbstractionId.nickName = "-";
		linkAbstraction.LinkAbstraction_init(&linkAbstractionId, this, &nodeTopology);
	};

	superNode = 0;
	newSuperNode = false;
	mySuperNodePDUProvider = myOldSuperNodePDUProvider = this->reset_anotherIdentity();
	nodeTicks = SYSTEM->msToTick(NODE_BACKGROUND_POLL);
	ticksDiff.tickPoint = 0;
	lastTicksRead = SYSTEM->getTicks();
	superNodePDUStatus.currentVersion = superNodePDUStatus.refreshCount = superNodePDUStatus.reissueCount = 0;
	superNodePDUStatus.timeToLive.tickPoint = 0;
	superNodePDUStatus.superNodeRef = 0;

	for (i = 0; i < MAX_OLDSUPERNODES; i++) {
		oldSuperNodeStatus[i] = 0;
	}

	reissueLogIndex = nextReissueLogIndex = 0;

	for (i = 0; i < MAX_REISSUELOG; i++) {
		reissueLog[i].initialized = false;
		reissueLog[i].issueNode = reissueLog[i].linkId = reissueLog[i].origNode.nodeId = this->reset_anotherIdentity();
		reissueLog[i].linkAbstraction = 0;
		reissueLog[i].msgType = reissueLog[i].reissueMsg = GENMSG_UNDEFINED;
		reissueLog[i].PDU_number = reissueLog[i].PDU_size = reissueLog[i].PDU_TTL = 0;
		reissueLog[i].protTraceRef = 0;
		reissueLog[i].version = 0;
	}
	objPrint = OBJ_ALL;

	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(nodeTicks), CB_NODE, 0);
};

void Node::Node_delete() {  // This will delete everything which is running on this node, including node interfaces and the switchCore
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, delete\n");}

	NodeTopologyItem_s *nodeTopItem;

	if (myNodeInfo.coreNode == true) {
		nodeTopItem = nodeTopology.getNext_nodeTopItem(false);

		while (nodeTopItem != 0) {
			this->detach_extLink(nodeTopItem->nodeInterface, nodeTopItem->attachedExtLink);
			this->detach_intLink(nodeTopItem->nodeInterface, 0, nodeTopItem->attachedIntLink);
			this->uninstall_nodeInf(nodeTopItem->nodeInterface);
			nodeTopItem->nodeInterface->NodeInterface_delete();
			delete nodeTopItem->nodeInterface;
			nodeTopItem = nodeTopology.getNext_nodeTopItem(false);
		}

	}
	else {  // The node is a superNode
		linkAbstraction.LinkAbstraction_delete();
	};

	nodeTopology.NodeTopology_delete();
	remoteExtNodeTopology.RemoteNodeTopology_delete();
	sortedTopology.SortedTopology_delete();
	centroid.Centroid_delete();
	switchCore.SwitchCore_delete();

	if (callbackRef != -1) {
		SYSTEM->delete_ticksQueueEvent(callbackRef);
		callbackRef = -1;
		cout << "Node Callback\n";
	}

	this->Entity_delete();
};

int Node::install_nodeInf(NodeInterface *nodeInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, install_nodeInf\n");}

	if (currentNoInterfaces < myNodeInfo.nodeTraits.maxInf) {

		if (nodeTopology.isNodeInf_installed(nodeInf) == false) {
			nodeTopology.add_nodeInterface(nodeInf);
			currentNoInterfaces++;
			return (0);
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "install_nodeInf", "Node_interface_already_installed", SYS_ERR_HARD);
			return (-1);
		}
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "install_nodeInf", "No_interfaces_has_reached_limit", SYS_ERR_HARD);
		return(-1);
	}

};

int Node::uninstall_nodeInf(NodeInterface *nodeInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, uninstall_nodeInf\n");}

	if (nodeTopology.isNodeInf_installed(nodeInf) == true) {
		nodeTopology.remove_nodeInterface(nodeInf);
		currentNoInterfaces--;
		return (0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "uninstall_nodeInf", "Node_interface_doesn't_exist", SYS_ERR_HARD);
		return (-1);
	};
};

int Node::update_neighborStatus(NodeInterface *nodeInf, NeighborNodeInfo_s *neighborInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, update_neighborStatus\n");}
	nodeTopology.update_neighbors(nodeInf, neighborInfo);
	return(0);
};

int Node::update_extNodeTopStatus(NodeInterface *nodeInf, ExtNodeTopInfo_s *extNodeTopInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, update_extNodeTopStatus\n");}
	remoteExtNodeTopology.update_extNodeTopStatus(nodeInf, extNodeTopInfo);
	return(0);
};

int Node::update_ownNodeTopStatus(MsgBody_ExtNodeTop_s *ownTopInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, update_ownNodeTopStatus\n");}
	remoteExtNodeTopology.update_ownNodeTopStatus(ownTopInfo);
	return(0);
};

int Node::update_centroidStatus(NodeInterface *nodeInf, CentroidInfo_s *centroidInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, update_centroidStatus\n");}
	centroid.update_centroidStatus(nodeInf, centroidInfo);
	return(0);
};

int Node::update_superNodeStatus(NodeInterface *nodeInf, SuperNodeInfo_s *superNodeInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, update_superNodeStatus\n");}
	ReissueInfo_s reissueInfo;

	if (get_identity().name.name == 737) {
		cout << "update_superNodeStatus";
	}

	if (superNodeInfo->msgType == SUPERNODE) {
		myOldSuperNodePDUProvider = mySuperNodePDUProvider;
		mySuperNodePDUProvider = superNodeInfo->origNode.nodeId;
	}

	// Check whether received PDU is a duplicate of an already received PDU. If yes, it should be silently dropped.
	if (superNodeInfo->msgType == SUPERNODE) {

		if (superNodeInfo->version > superNodePDUStatus.currentVersion || superNodeInfo->superNodeRef != superNode) { // This is not a duplicate, OR it might be superNode info from another domain which this node has moved into
			superNodePDUStatus.currentVersion = superNodeInfo->version;
			superNodePDUStatus.PDU_TTL = superNodeInfo->PDU_TTL;
			superNodePDUStatus.timeToLive = superNodeInfo->timeToLive;
			superNodePDUStatus.refreshCount = 0;
			superNodePDUStatus.nodeInf = nodeInf;

			if (this->get_identity().name.name == 1276) {
//				string input;
				cout << "\nTickpoint: " << SYSTEM->getTicks().tickPoint << " Node " << this->get_identity().name.name << " received SUPERNODE PDU from Node: " << superNodeInfo->origNode.nodeId.name.name << "\n";// cin >> input;

				if (SYSTEM->getTicks().tickPoint == 31410) {
					SYSTEM->breakExecution(SYSTEM->getTicks());
				}

			}


			superNode = superNodePDUStatus.superNodeRef = superNodeInfo->superNodeRef;

			// Update node interfaces with respect to domain interface status, and save the domain node set
			centroid.update_nodeInfDomainLevel();
			centroid.saveDomain(&superNodeInfo->origNode.nodeId, &superNodeInfo->superNodeRef->get_identity());

			// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received, but only if the interface is an intra-domain inf. NB!!! Only works if all nodes on an inter-domain inf belong to other domains. 
			if (superNodeInfo->PDU_TTL > 0) {
				this->resend_PDU(nodeInf, superNodeInfo);
			};

		}
		else if (superNodeInfo->version == superNodePDUStatus.currentVersion && superNodeInfo->PDU_TTL > superNodePDUStatus.PDU_TTL) { // This is a duplicate however recieved with a higher TTL which needs to be re-distributed to ensure proper dissemination, also covers retransmission of a reissuing request received with a higher TLL
				// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received, but only if the interface is an intra-domain inf. NB!!! Only works if all nodes on an inter-domain inf belong to other domains. 

			if (superNodeInfo->PDU_TTL > 0) {
				this->resend_PDU(nodeInf, superNodeInfo);
			};

			superNodePDUStatus.PDU_TTL = superNodeInfo->PDU_TTL;
			superNodePDUStatus.nodeInf = nodeInf;
		}
		else if (superNodeInfo->version == superNodePDUStatus.currentVersion && superNodeInfo->reissue == true) { // This is a reissueing request, AND a refresh as well
				// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received, but only if the interface is an intra-domain inf. NB!!! Only works if all nodes on an inter-domain inf belong to other domains. 
			superNodePDUStatus.refreshCount = superNodeInfo->refreshCount;
			superNodePDUStatus.PDU_TTL = superNodeInfo->PDU_TTL;
			superNodePDUStatus.timeToLive = superNodeInfo->timeToLive;
			superNodePDUStatus.nodeInf = nodeInf;

			if (superNodeInfo->PDU_TTL > 0) {
				this->resend_PDU(nodeInf, superNodeInfo);
			};

		}; // ENDIF check for duplicates

	}
	else if (superNodeInfo->msgType == SUPERNODE_REFRESH && globalNameSpace->check_ifEqual(superNodeInfo->origNode.nodeId.name, mySuperNodePDUProvider.name) == true) {  // Only accept a REFRESH from the current provider
		// Check whether a reissueing might be needed
		if (superNodePDUStatus.superNodeRef == 0 || superNodePDUStatus.currentVersion != superNodeInfo->version) {  // NB!!! Not sure whether this cover mobility aspects.
			reissueInfo.initialized = true;
			reissueInfo.processed = false;
			reissueInfo.issueNode = superNodeInfo->origNode.nodeId;
			reissueInfo.reissueMsg = SUPERNODE;
			reissueInfo.version = superNodeInfo->version;
			reissueInfo.refreshCount = superNodeInfo->refreshCount;
			this->reissueMsgMgmt(nodeInf, &reissueInfo);
		}
		else { // A "normal" refresh

			if (superNodeInfo->refreshCount > superNodePDUStatus.refreshCount || superNodeInfo->superNodeRef != superNode) { // This is not a duplicate, and might be a refresh from a new domain which this node has moved into
				superNodePDUStatus.currentVersion = superNodeInfo->version;
				superNodePDUStatus.refreshCount = superNodeInfo->refreshCount;
				superNodePDUStatus.PDU_TTL = superNodeInfo->PDU_TTL;
				superNodePDUStatus.timeToLive = superNodeInfo->timeToLive;
				superNodePDUStatus.nodeInf = nodeInf;

				superNode = superNodePDUStatus.superNodeRef = superNodeInfo->superNodeRef;

				if (this->get_identity().name.name == 2942 || this->get_identity().name.name == 2599) {
//					string input;
					cout << "\nTickpoint: " << SYSTEM->getTicks().tickPoint << " Node " << this->get_identity().name.name << " received SUPERNODE PDU from Node: " << superNodeInfo->origNode.nodeId.name.name << "\n";// cin >> input;
				}

				// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received. See also comment above for SUPERNODE PDU.
				if (superNodeInfo->PDU_TTL > 0) {
					this->resend_PDU(nodeInf, superNodeInfo);
				}

			}
			else if (superNodeInfo->refreshCount == superNodePDUStatus.refreshCount && superNodeInfo->PDU_TTL > superNodePDUStatus.PDU_TTL) {  // This is a duplicate however recieved with a higher TTL which needs to be re-distributed to ensure proper dissemination
			// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received, and except for the one at which the duplicate was received
				
				if (superNodeInfo->PDU_TTL > 0) {
					this->resend_PDU(nodeInf, superNodeInfo);
				}

				superNodePDUStatus.PDU_TTL = superNodeInfo->PDU_TTL;
				superNodePDUStatus.nodeInf = nodeInf;
			}; // ENDIF check for duplicates

		};  // ENDIF check for reissueing

	};  // ENDIF msgType
		
	return (0);
};

int Node::update_linkAbstractionStatus(Identity_s *infId, Identity_s *nodeId, LinkAbstractionInfo_s *linkAbstractionInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, update_linkAbstractionStatus\n");}
	linkAbstraction.update_linkAbstractionStatus(infId, nodeId, linkAbstractionInfo);
	return (0);
};

int Node::pass_linkAbstractionInfo(Identity_s *infId, Identity_s *nodeId, LinkAbstractionInfo_s *linkAbstractionInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, pass_linkAbstractionInfo\n");}
	
	if (superNode != 0) {
		superNode->update_linkAbstractionStatus(infId, nodeId, linkAbstractionInfo);
		return(0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "pass_linkAbstractionInfo", "No_supernode_exists", SYS_ERR_SOFT); 
		return(-1);
	};

};

int Node::resend_PDU(NodeInterface *nodeInf, SuperNodeInfo_s *superNodeInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, resend_PDU\n");}
	MsgBody_SuperNode_s *superNodeBody;
	MsgBody_SuperNodeRefresh_s *superNodeRefreshBody;
	GenericPDU_s *pdu;
	NodeInterface *localNodeInf;

	localNodeInf = nodeTopology.getNext_nodeInterface(false);
				
	while (localNodeInf != 0) {

		if (localNodeInf != nodeInf && localNodeInf->is_domainInterface() == false && localNodeInf->isExtInterfaceRunning() == true) {
			try {
				pdu = new GenericPDU_s;

				if (superNodeInfo->msgType == SUPERNODE) {
					superNodeBody = new MsgBody_SuperNode_s;
				}
				else {
					superNodeRefreshBody = new MsgBody_SuperNodeRefresh_s;
				}

			} catch (bad_alloc xa) {
				SYSTEM->runtimerror(&get_identity(), "resend_PDU", "memory_allocation_failure", SYS_ERR_HARD);
				return (-1);
			}

			pdu->header.msgType = superNodeInfo->msgType;
			pdu->header.PDU_TTL = superNodeInfo->PDU_TTL;
			pdu->header.numberDest = 0;
			pdu->protTraceRef = superNodeInfo->protTraceRef;


			if (superNodeInfo->msgType == SUPERNODE) {
				pdu->header.PDU_size = sizeof(GenericPDU_SuperNode_s);
				superNodeBody->version = superNodeInfo->version;
				superNodeBody->reissue = superNodeInfo->reissue;
				superNodeBody->sourceNode = superNodeInfo->origNode;
				superNodeBody->superNodeRef = superNodeInfo->superNodeRef;
				pdu->msgBody.superNodeBody = superNodeBody;
			}
			else {  // A refresh
				pdu->header.PDU_size = sizeof(GenericPDU_SuperNodeRefresh_s);
				superNodeRefreshBody->version = superNodeInfo->version;
				superNodeRefreshBody->refreshCount = superNodeInfo->refreshCount;
				superNodeRefreshBody->sourceNode = superNodeInfo->origNode;
				superNodeRefreshBody->superNodeRef = superNodeInfo->superNodeRef;
				pdu->msgBody.superNodeRefreshBody = superNodeRefreshBody;
			};

			localNodeInf->send_PDU(INF_EXTERNAL, pdu);
		}

		localNodeInf = nodeTopology.getNext_nodeInterface(false);
	};

	return(0);
};
bool Node::check_ifLinkBuilder(NodeInterface *nodeInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, check_ifLinkBuilder\n");}
	return (nodeTopology.check_ifLinkBuilder(nodeInf));
};

bool Node::check_ifDomainNode(Identity_s *nodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, check_ifDomainNode\n");}
	return (centroid.check_ifDomainNode(nodeId));
};

bool Node::check_databaseConsistency() {  // This function checks that the databases in RemoteNodeTopology, SortedTopology, and Centroid are consistent with each other
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, check_databaseConsistency\n");}
	RemoteCentroidItem_s *centroidItem;
	TierNodeItem_s tierNodeItem;
	bool consistency;

	consistency = true;

	if (sortedTopology.get_currentNumberTierItems() == centroid.get_currentNumberCentroids() == remoteExtNodeTopology.get_currentNumberNodeTopologies()) {
		centroid.getNext_remoteCentroidItem(false);  // Skip the first node which is this node
		centroidItem = centroid.getNext_remoteCentroidItem(false);

		while (centroidItem != 0 && consistency == true) {
			tierNodeItem = sortedTopology.find_tierNodeItem(&(centroidItem->centroidInfo.origNode.nodeId));

			if (tierNodeItem.tier == -1) { // There is no matching node
				consistency = false;
			}
			else {
				
				if (remoteExtNodeTopology.get_remoteTopItem(&tierNodeItem.remoteNodeTop->origNode.nodeId) == 0) {
					consistency = false;
				}

			};

			centroidItem = centroid.getNext_remoteCentroidItem(false);
		};

	}
	else {
		consistency = false;
	};

	centroidItem = centroid.getNext_remoteCentroidItem(true);
	return(consistency);
};

bool Node::check_domainConsistency() {// This function checks that the databases in RemoteNodeTopology, SortedTopology, and Centroid are consistent with each other WITHIN the domain
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, check_domainConsistency\n");}
	RemoteCentroidItem_s *centroidItem;
	TierNodeItem_s tierNodeItem;
	bool consistency;
	int numberCentroids;

	consistency = true;

	centroid.getNext_remoteCentroidItem(false);  // Skip the first node which is this node
	numberCentroids = 1;
	centroidItem = centroid.getNext_remoteCentroidItem(false);

	while (centroidItem != 0 && consistency == true) {

		if (centroid.check_ifDomainNode(&centroidItem->centroidInfo.origNode.nodeId) == true) {
			numberCentroids++;
			tierNodeItem = sortedTopology.find_tierNodeItem(&(centroidItem->centroidInfo.origNode.nodeId));

			if (tierNodeItem.tier == -1) { // There is no matching node
				consistency = false;
			}
			else {
				
				if (remoteExtNodeTopology.get_remoteTopItem(&tierNodeItem.remoteNodeTop->origNode.nodeId) == 0) {
					consistency = false;
				}

			};

		};

		centroidItem = centroid.getNext_remoteCentroidItem(false);
	};

	centroidItem = centroid.getNext_remoteCentroidItem(true);

	if (consistency == true) {  // Check also that number of nodes found corresponds to number of listed domain nodes

		if (numberCentroids != centroid.get_currentNumberDomainNodes()) {
			consistency = false;
		}

	}

	return(consistency);
};

Identity_s Node::check_mySuperNodePDUProvider(Identity_s *superNodePDU_origId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, check_mySuperNodePDUProvider\n");}
	CentroidItem_s *centroidStatus;
	Identity_s oldSuperNodePDUProvider;

	// Only accept SUPERNODE PDUs from the assigned provider, and which may change upon reception of a SUPERNODE PDU
	oldSuperNodePDUProvider = mySuperNodePDUProvider;
	centroidStatus = centroid.get_centroidStatus(&this->get_identity());

	if (globalNameSpace->check_ifValid(centroidStatus->currentCentroid.name) == true) {
		
		if (globalNameSpace->check_ifEqual(centroidStatus->currentCentroid.name, superNodePDU_origId->name) == true) {  // Don't change provider to the current centroid until the first SUPERNODE PDU has been received
			mySuperNodePDUProvider = centroidStatus->currentCentroid;
		}
		else {  // Keep to old centroid node for the time being, if existing
			mySuperNodePDUProvider = centroid.get_savedDomainCentroidNode();  // Will return an invalid ID in case of no old centroid§
		};

	}
	else {  // Keep to old centroid node for the time being, if existing
		mySuperNodePDUProvider = centroid.get_savedDomainCentroidNode();  // Will return an invalid ID in case of no old centroid§
	};

	if (SYS_eventTrace == true) {

		if (globalNameSpace->check_ifEqual(oldSuperNodePDUProvider.name, mySuperNodePDUProvider.name) == false) {
			Identity_s idArray[2];
			idArray[0] = mySuperNodePDUProvider;
			idArray[1] = this->reset_anotherIdentity();
			SYSTEM->eventTrace(&get_identity(), &get_identity(), SYS_LL_HIGH, "Changed_superNodePDU_provider", 0, 0, 0, idArray);
		}

	}

	return (mySuperNodePDUProvider);
};

NodeInterface *Node::get_nodeInterface(Identity_s *linkId, Identity_s *nodeInfId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_nodeInterface\n");}
	return(nodeTopology.get_nodeInterface(linkId, nodeInfId));
};

NodeTopologyItem_s Node::getNext_nodeTopItem(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, getNext_nodeTopItem\n");}
	NodeTopologyItem_s dummyNodeTopItem, *nodeTopItem;

	nodeTopItem = nodeTopology.getNext_nodeTopItem(reset);

	if (nodeTopItem != 0) {
		return(*nodeTopItem);
	}
	else {
		// Return a dummy item
		dummyNodeTopItem.nodeInterface = 0;
		return(dummyNodeTopItem);
	};

};

NodeInterface *Node::getNext_nodeInterface(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, getNext_nodeInterface\n");}
	return (nodeTopology.getNext_nodeInterface(reset));
};

RemoteTopologyItem_s *Node::getNext_remoteTopItem(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, getNext_remoteTopItem\n");}
	return (remoteExtNodeTopology.getNext_remoteTopItem(reset));
};

RemoteTopologyItem_s *Node::getNext_domainNode(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, getNext_domainNode\n");}	
	return(centroid.getNext_domainNode(reset));
};
Identity_s Node::getNext_domainNodeId(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, getNext_domainNodeId\n");}	
	return(centroid.getNext_domainNodeId(reset));
};
int Node::get_nodeTopVersion() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_nodeTopVersion\n");}
	return (nodeTopology.get_nodeTopVersion());
};

int Node::get_ownNodeTopVersion() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_ownNodeTopVersion\n");}
	return (remoteExtNodeTopology.get_currentVersion());
};

int Node::get_extTopRefreshCount() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_extTopRefreshCount\n");}
	return (nodeTopology.get_refreshCount());
};

int Node::get_extTopReissueCount() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_extTopReissueCount\n");}
	return(remoteExtNodeTopology.get_reissueCount());
};
CentroidItem_s *Node::get_centroidStatus(Identity_s *id) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_centroidStatus\n");}
	return(centroid.get_centroidStatus(id));
};

float Node::get_centroidScore() {
	return(centroid.get_centroidScore());
};

int Node::get_centroidRefreshCount() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_centroidRefreshCount\n");}
	return (centroid.get_refreshCount());
};

int Node::get_centroidReissueCount() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_centroidReissueCount\n");}
	return (centroid.get_reissueCount());
};

int Node::get_currentNumberDomainNodes() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_currentNumberDomainNodes\n");}
	return (centroid.get_currentNumberDomainNodes());
};
int Node::get_centroidVersion() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_centroidVersion\n");}
	return (centroid.get_centroidVersion());
};

RouteSegment_s Node::get_firstRouteSegment(Identity_s *destNodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_firstRouteSegment\n");}
	return (sortedTopology.get_firstRouteSegment(destNodeId));
};
int Node::get_netNeighborhood() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_netNeighborhood\n");}
	return (centroid.get_netNeighborhood());
};

Identity_s Node::get_superNodePDUProvider(bool old) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_superNodePDUProivider\n");}
	
	if (old == true) {
		return (myOldSuperNodePDUProvider);
	}
	else {
		return (mySuperNodePDUProvider);
	};

};

SuperNodePDU_Status_s Node::get_superNodePDUStatus() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_superNodePDUStatus\n");}
	return(superNodePDUStatus);
};

NodeInfo_s *Node::get_myNodeInfo() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_myNodeInfo\n");}
	return(&myNodeInfo);
};

Identity_s Node::get_superNodeId() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_superNodeId\n");}

	Identity_s superNodeId;

	if (superNode != 0) {
		superNodeId = superNode->get_myNodeInfo()->nodeId;
	}
	else {
		superNodeId = this->reset_anotherIdentity();
	};

	return (superNodeId);
};

NodeInfo_s *Node::get_superNodeInfo() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_superNodeStatus\n");}

	if (superNode != 0) {
		return(superNode->get_myNodeInfo());
	}
	else {
		return(0);
	};

};

Node *Node::get_subNodeRef() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_subNodeRef\n");}
	return(subNode);
};

int Node::get_currentNumberNodeInf() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_currentNumberNodeInf\n");}
	return(currentNoInterfaces);
};

int Node::update_centroidNode(Node *centroidNode) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, update_centroidInfo\n");}
	subNode = centroidNode;
	return(0);
};

LinkAbstInfo_s *Node::get_nextLinkAbstFromSN(Identity_s *linkId, Identity_s *superNodeId, bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_nextLinkAbstFromSN\n");}

	if (superNode != 0) {
		return(superNode->get_nextLinkAbst(linkId, superNodeId, reset));
	}
	else {
		return(0);
	};

};

ReissueInfo_s *Node::get_nextReissueReqFromSN(GenericMsgType msgType, Identity_s *linkId, bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_nextReissueReqFromSN\n");}

	if (superNode != 0) {
		return(superNode->get_nextReissueReq(msgType, linkId, reset));
	}
	else {
		return(0);
	};

};

LinkAbstInfo_s *Node::get_nextLinkAbst(Identity_s *linkId, Identity_s *superNodeId, bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_nextLinkAbst\n");}
	return(linkAbstraction.get_nextLinkAbst(linkId, superNodeId, reset));
};

ReissueInfo_s *Node::get_nextReissueReq(GenericMsgType msgType, Identity_s *linkId, bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_nextReissueReq\n");}
	int currentReissueLogIndex;
	bool logEntryFound;

	if (nextReissueLogIndex == MAX_REISSUELOG || reset == true) {
		nextReissueLogIndex = 0;
		return(0);
	}
	else {
		logEntryFound = false;

		while (nextReissueLogIndex < MAX_REISSUELOG && logEntryFound == false) {
		
			if (reissueLog[nextReissueLogIndex].processed == false) {

				if (reissueLog[currentReissueLogIndex].msgType == msgType && globalNameSpace->check_ifEqual(linkId->name, reissueLog[currentReissueLogIndex].linkId.name) == true) {
					currentReissueLogIndex = nextReissueLogIndex;
					logEntryFound = true;
				}
				else {
					nextReissueLogIndex++;
				};

			}
			else {
				nextReissueLogIndex++;
			};

		}

		if (nextReissueLogIndex < MAX_REISSUELOG) {
			return(&reissueLog[currentReissueLogIndex]);
		}
		else {
			return(0);
		};

	};

};

NodeCoordinates_s Node::get_coordinates() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, get_coordinates\n");}
	return (currentPos);
};

int Node::set_coordinates(NodeCoordinates_s coord) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, set_coordinates\n");}
	// To be defined!!!
	SYSTEM->runtimerror(&get_identity(), "set_coordinates", "non-implmented_feature", SYS_ERR_SOFT);
	return(-1);
};

SwitchCoreInterface *Node::find_switchCoreInf(Link *intLink) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, find_switchCoreInf\n");}
	return(switchCore.find_switchInf(intLink));
};

int Node::attach_extLink(NodeInterface *nodeInf, Link *link, LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, attach_extLink\n");}

	if (nodeTopology.isNodeInf_installed(nodeInf) == true) {

		if (nodeInf->attach_linkExt(link, linkEndpoint) == 0) {
			nodeTopology.add_extLink(nodeInf, link, linkEndpoint);
			nodeInf->start_extInterface();
			return (0);
		};
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "attach_extLink","Invalid_node_interface", SYS_ERR_HARD);
		return (-1);
	};

};

int Node::detach_extLink(NodeInterface *nodeInf, Link *link) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, detach_extLink\n");}
	
	if (nodeTopology.isNodeInf_installed(nodeInf) == true) {
		nodeInf->detach_linkExt(link);
		nodeTopology.remove_extLink(nodeInf, link);
		return (0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "detach_extLink","Invalid_node_interface", SYS_ERR_HARD);
		return (-1);
	}
};

int Node::attach_intLink(NodeInterface *nodeInf, SwitchCoreInterface *switchInf, Link *link, LinkEndpoint *linkEndpointInfInt, LinkEndpoint *linkEndpointSwitchInf) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, attach_intLink\n");}

	if (nodeTopology.isNodeInf_installed(nodeInf) == true) {
		nodeInf->attach_linkInt(link, linkEndpointInfInt);
		nodeTopology.add_intLink(nodeInf, link, linkEndpointInfInt);

		if (switchCore.isSwitchInf_installed(switchInf) == true) {
			switchInf->attach_link(link, linkEndpointSwitchInf);
			return (0);
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "attach_intLink","Invalid_switch_core_interface", SYS_ERR_HARD);
			return (-1);
		};

	}
	else {
		SYSTEM->runtimerror(&get_identity(), "attach_intLink","Invalid_node_interface", SYS_ERR_HARD);
		return (-1);
	};

};

int Node::detach_intLink(NodeInterface *nodeInf, SwitchCoreInterface *switchInf, Link *link) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, detach_intLink\n");}

	// Either of nodeInf or switchInf might be 0 in which case link will NOT be detached from that interface
	
	if (nodeInf != 0) {
	
		if (nodeTopology.isNodeInf_installed(nodeInf) == true) {  // Was here before a test that coreNode == true, can't see a need for that???
			nodeInf->detach_linkInt(link);
			nodeTopology.remove_intLink(nodeInf, link);
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "detach_intLink","Invalid_node_interface", SYS_ERR_HARD);
			return (-1);
		}

	}

	if (switchInf != 0) {

		if (switchCore.isSwitchInf_installed(switchInf)) {
			switchInf->detach_link(link);
			return (0);
		}
		else {
			SYSTEM->runtimerror(&get_identity(), "detach_intLink","Invalid switch_core_interface", SYS_ERR_HARD);
			return (-1);
		}

	}

	return(0);
};

int Node::attach_verDownLink(NodeInterface *nodeInf, Link *link, LinkEndpoint *linkEndpoint) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, attach_verDownLink\n");}

	if (nodeTopology.isNodeInf_installed(nodeInf) == true) {
		nodeInf->attach_linkVerDown(link, linkEndpoint);
		return (0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "attach_verDownLink","Invalid_node_interface", SYS_ERR_HARD);
		return (-1);
	}
};

int Node::detach_verDownLink(NodeInterface *nodeInf, Link *link) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, detach_verDownLink\n");}	

	if (nodeTopology.isNodeInf_installed(nodeInf) == true) {
		nodeInf->detach_linkVerDown(link);
		return (0);
	}
	else {
		SYSTEM->runtimerror(&get_identity(), "detach_verDownLink","Invalid_node_interface", SYS_ERR_HARD);
		return (-1);
	}
};

int Node::reissueMsgMgmt(NodeInterface *nodeInf, ReissueInfo_s *reissueInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, reissueMsgMgmt\n");}
	RouteSegment_s firstRouteSegment;
	NodeInterface *nodeInterface;
	GenericPDU_s *pdu;
	MsgBody_Reissue_s *reissueBody;
	int logIndex;
	bool inLog, retransmit, doBroadcast;

	// First check if this is the node that shall do the reissueing of the message
	if (globalNameSpace->check_ifEqual(reissueInfo->issueNode.name, get_identity().name) == true) {
		// Forward on to the module to handle the reissueing

		if (reissueInfo->reissueMsg == EXT_NODETOPOLOGY) {
			remoteExtNodeTopology.reissue_extNodeTopStatus(nodeInf, reissueInfo);
		}
		else if (reissueInfo->reissueMsg == CENTROID) {
			centroid.reissue_centroidStatus(nodeInf, reissueInfo);
		}
		else if (reissueInfo->reissueMsg == SUPERNODE) {
			this->reissue_superNodeStatus(nodeInf, reissueInfo);
		}
		else if (reissueInfo->reissueMsg == LINK_ABSTRACTION) {
			linkAbstraction.reissue_linkAbstractionStatus(nodeInf, reissueInfo);
		};

	}
	else { // This is either a request for reissueing or a forwarding of a reissueing request
		// First check if a reissue request already has been submitted or been forwarded for the identified node and message type
		logIndex = (reissueLogIndex - 1);
		inLog = retransmit = false;
		pdu = 0;

		if (logIndex == -1) {
			logIndex = MAX_REISSUELOG-1;
		}

		while (logIndex != reissueLogIndex && inLog == false) {
		
			if (globalNameSpace->check_ifEqual(reissueLog[logIndex].issueNode.name, reissueInfo->issueNode.name) == true) {

				if (reissueLog[logIndex].reissueMsg == reissueInfo->reissueMsg && reissueLog[logIndex].version == reissueInfo->version && reissueInfo->refreshCount == reissueLog[logIndex].refreshCount) {
					inLog = true;
				}
				else {
					logIndex--;
				}

			}
			else {
				logIndex--;
			};

			if (inLog == false && logIndex == -1) {
				logIndex = MAX_REISSUELOG-1;
			}

		}

		// If in log, and if not reissue request was initialized by this node, check whether TTL is higher for the received reissue request
		if (inLog == true && reissueLog[logIndex].initialized == false) {

			if (reissueInfo->PDU_TTL > reissueLog[logIndex].PDU_TTL) {
				// perform retransmission
				retransmit = true;
			}

		}

		if (inLog == false || retransmit == true) {
			doBroadcast = false;
			// First check whether a route exist to the issue NodeId, if yes, send just like a unicast (however will still be sent with a broadcast address), if no, broadcast across all interfaces
			firstRouteSegment = sortedTopology.get_firstRouteSegment(&reissueInfo->issueNode);
			nodeInterface = 0;

			if (globalNameSpace->check_ifValid(firstRouteSegment.nodeId.name) == true) {
				nodeInterface = nodeTopology.get_nodeInterface(0, &firstRouteSegment.exitNodeInfId);
			}

			if (nodeInterface != 0) {
			
				if (nodeInterface->isExtInterfaceRunning() == true) {  // If not, better try broadcast							
					try {
						pdu = new GenericPDU_s;
						reissueBody = new MsgBody_Reissue_s;
					} catch (bad_alloc xa) {
						SYSTEM->runtimerror(&get_identity(), "reissueMsgMgmt", "memory_allocation_failure", SYS_ERR_HARD);
						return (-1);
					}

					pdu->header.msgType = REISSUE;
					pdu->header.PDU_size = sizeof(GenericPDU_Reissue_s);
					pdu->header.numberDest = 0;

					if (reissueInfo->initialized == true) {
						pdu->header.PDU_TTL = this->get_netNeighborhood();
						pdu->header.sourceNode.nodeId = myNodeInfo.nodeId;  // Actually not needed to be filled in here, but needed for the protTrace
						pdu->header.sourceNode.nodeInfId = nodeInterface->get_identity();
						pdu->protTraceRef = 0;
					}
					else {
						pdu->header.PDU_TTL = reissueInfo->PDU_TTL;
						pdu->protTraceRef = reissueInfo->protTraceRef;
					};

					reissueBody->issueNode = reissueInfo->issueNode;
					reissueBody->sourceNode = myNodeInfo;
					reissueBody->reissueMsg = reissueInfo->reissueMsg;
					reissueBody->version = reissueInfo->version;
					reissueBody->refreshCount = reissueInfo->refreshCount;
					pdu->msgBody.reissueBody = reissueBody;
					nodeInterface->send_PDU(INF_EXTERNAL, pdu);
				}
				else {  // Broadcast unto all interfaces
					doBroadcast = true;
				};

			}
			else {
				doBroadcast = true;
			};

			if (doBroadcast == true) {
				nodeInterface = nodeTopology.getNext_nodeInterface(false);

				while (nodeInterface != 0) {

					if (nodeInterface->isExtInterfaceRunning() == true) {							
						try {
							pdu = new GenericPDU_s;
							reissueBody = new MsgBody_Reissue_s;
						} catch (bad_alloc xa) {
							SYSTEM->runtimerror(&get_identity(), "reissueMsgMgmt", "memory_allocation_failure", SYS_ERR_HARD);
							return (-1);
						}

						pdu->header.msgType = REISSUE;
						pdu->header.numberDest = 0;
						pdu->header.PDU_size = sizeof(GenericPDU_Reissue_s);

						if (reissueInfo->initialized == true) {
							pdu->header.PDU_TTL = this->get_netNeighborhood();
							pdu->header.sourceNode.nodeId = myNodeInfo.nodeId;// Actually not needed to be filled in here, but needed for the protTrace
							pdu->header.sourceNode.nodeInfId = nodeInterface->get_identity();
//							pdu->protTraceRef = SYSTEM->init_protTrace(pdu, 0, REISSUE);
							pdu->protTraceRef = 0;
						}
						else {
							pdu->header.PDU_TTL = reissueInfo->PDU_TTL;
							pdu->protTraceRef = reissueInfo->protTraceRef;
						};

						reissueBody->issueNode = reissueInfo->issueNode;
						reissueBody->sourceNode = myNodeInfo;
						reissueBody->reissueMsg = reissueInfo->reissueMsg;
						reissueBody->version = reissueInfo->version;
						reissueBody->refreshCount = reissueInfo->refreshCount;
						pdu->msgBody.reissueBody = reissueBody;
						nodeInterface->send_PDU(INF_EXTERNAL, pdu);
					}

					nodeInterface = nodeTopology.getNext_nodeInterface(false);
				};  // ENDWHILE nodeInterface

			}  // ENDIF doBroadcast

			// Store in reissueLog, ONLY IF SOMETHING BEEN SENT!!!
			if (pdu != 0) {

				if (reissueInfo->initialized == true) {
					if (SYS_eventTrace == true) {SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_LOW, "Reissue_requested", (int *) &pdu->msgBody.reissueBody->reissueMsg, 0, 0, 0);}
					reissueInfo->PDU_TTL = pdu->header.PDU_TTL;
				}

				if (retransmit == false) {
					reissueLog[reissueLogIndex++] = *reissueInfo;
					reissueLogIndex &= (MAX_REISSUELOG-1);
				}
				else {
					reissueLog[logIndex] = *reissueInfo;  // Overwrite the old one with this one having a higher PDU_TTL
				};

				reissueLog[logIndex].processed = true;
			}

		}  // ENDIF inLog, retransmit

	};  // ENDIF reissueing node

	return(0);
};				

int Node::reissueMsgMgmt_linkAbst(ReissueInfo_s *reissueInfo) {  // Only used when transmitting a reissue request for a LINK_ABSTRACTION!!!
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, reissueMsgMgmt_linkAbst\n");}
	NodeInterface *nodeInterface;
	GenericPDU_s *pdu;
	MsgBody_Reissue_s *reissueBody;
	int logIndex;
	bool inLog, retransmit;

	// First check if a reissue request already has been submitted or been forwarded for the identified node and message type
	logIndex = (reissueLogIndex - 1);
	inLog = retransmit = false;
	pdu = 0;

	if (logIndex == -1) {
		logIndex = MAX_REISSUELOG-1;
	}

	while (logIndex != reissueLogIndex && inLog == false) {
		
		if (reissueLog[logIndex].linkAbstraction == reissueInfo->linkAbstraction) {

			if (globalNameSpace->check_ifEqual(reissueLog[logIndex].linkId.name,reissueInfo->linkId.name) == true && reissueLog[logIndex].version == reissueInfo->version && reissueLog[logIndex].refreshCount == reissueInfo->refreshCount) {
				inLog = true;
			}
			else {
				logIndex--;
			}

		}
		else {
			logIndex--;
		};

		if (inLog == false && logIndex == -1) {
			logIndex = MAX_REISSUELOG-1;
		}

	}

	// Only store this in reissueLog, will later be processed by underlying nodes in lower domain level
	if (inLog == false) {
		reissueInfo->PDU_TTL = pdu->header.PDU_TTL;
		reissueLog[reissueLogIndex++] = *reissueInfo;
		reissueLogIndex &= (MAX_REISSUELOG-1);
		if (SYS_eventTrace == true) {SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_LOW, "Reissue_requested", (int *) &pdu->msgBody.reissueBody->reissueMsg, 0, 0, 0);}
	}  // ENDIF inLog

	return(0);
};

int Node::reissue_superNodeStatus(NodeInterface *nodeInf, ReissueInfo_s *reissueInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, reissue_superNodeStatus\n");}
	superNodePDUStatus.reissueCount++;
	return(0);
};

void Node::CALLBACK_tickZero(void *parameters, int secret) {
	if (SYS_threadTrace== true) { SYSTEM->threadTrace(&get_identity(), &get_identity());}
	CALLBACK_checkNodeStatus();

	ticksDiff.tickPoint += SYSTEM->subTicks(SYSTEM->getTicks(), lastTicksRead).tickPoint;
	lastTicksRead = SYSTEM->getTicks();

	if (ticksDiff.tickPoint > SYSTEM->msToTick(GP_SUPERNODE_INTERVAL).tickPoint && globalNameSpace->check_ifEqual(mySuperNodePDUProvider.name, get_identity().name) == true) {
		superNodePDUStatus.refreshCount++;
		ticksDiff.tickPoint = 0;
	};

	if (myNodeInfo.coreNode == false) {

		if (subNode != 0) {
			currentPos = subNode->get_coordinates();
		}

	}

	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(nodeTicks), CB_NODE, 0);
};

void Node::CALLBACK_checkNodeStatus() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, CALLBACK_checkNodeStatus\n");}
	Identity_s nodeId;
	NodeTraits_s nodeTraits;
	CentroidItem_s *centroidInfo;
	int i;
	bool oldSNPosFound;
	char nickName[80] = "SN_";
	// At the moment only status in regard of Centroid and Super Node is checked here

/*
IF this node is a stable centroid THEN
	check domain overlap between old domain (controlled by an old centroid) and the new domain (controlled by this centroid)

	IF domain overlap is not big enough THEN
		create new supernode
	ENDIF

	IF this node has just become centroid THEN
		start superNode protocol option
	END IF

ELSE IF this node was centroid but is no more centroid THEN
	stop superNode protocol option
ELSE IF this node is a centroid since before THEN
	send SuperNode PDU
ENDIF

*/

	centroidInfo = centroid.get_centroidStatus(&this->get_identity());
//	string input;

	if (centroid.is_stableCentroid() == true  && newSuperNode == false) {  // State = "NORMAL" assumed. This node has just become a stable Centroid
		if (SYS_eventTrace == true) { SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_MEDIUM, "New_stable_centroid", 0, 0, 0, 0);}

		newSuperNode = true;
		myOldSuperNodePDUProvider = mySuperNodePDUProvider;
		mySuperNodePDUProvider = this->get_identity();
		myNodeInfo.domainCenter = true;

		// Check if a new supernode shall be created

		if (centroid.compare_domainOverlap() == true || superNodePDUStatus.superNodeRef == 0) {  // There is a need for a new superNode
			// The old superNode, if existing, will be deleted by the caretaking node
			cout << "domainOverlap == true\n";// cin >> input;

			try {
				superNode = new Node;
			} catch (bad_alloc xa) {
				SYSTEM->runtimerror(&get_identity(), "CALLBACK_checkNodeStatus","allocation_failure", SYS_ERR_HARD);
			}

			nodeId.type = "NODE";

			if (myNodeInfo.coreNode == true) {
				nodeId.nickName = "SN_" + SYSTEM->find_nodeExtName(&this->get_identity());
			}
			else {
				nodeId.nickName = "SN_" + myNodeInfo.nodeId.nickName;
			};

			// Many of the traits are not really used and computed at the moment!!!
			nodeTraits.domainLevel = domainLevelAlg->increaseDomainLevel(myNodeInfo.nodeTraits.domainLevel);
			nodeTraits.genMemory.completionTime = nodeTraits.genMemory.mtbf = 0;
			nodeTraits.genProcessing.completionTime = nodeTraits.genProcessing.mtbf = 0;
			nodeTraits.maxInf = MAX_SUPERNODEINF;
			nodeTraits.memory.capacity = 0;
			nodeTraits.processing.capacity = 0;
			nodeTraits.switchCore.genSwitching.completionTime = nodeTraits.switchCore.genSwitching.mtbf = 0;
			nodeTraits.switchCore.maxInf = MAX_SN_SWITCHCOREINF;
			nodeTraits.switchCore.switching.capacity = 0;

			superNode->Node_init(&nodeId, myNodeInfo.domainRadius, this, nodeTraits, currentPos, NODE_TIMETOLIVE, &get_identity()); // The supernode will have a location that corresponds to the underlying position of the centroid
			SYSTEM->report_entityCreation(&get_identity(), &superNode->get_identity(), superNode);
			if (SYS_eventTrace == true) { SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_HIGH, "New_supernode", (int *) &superNode->get_myNodeInfo()->nodeId.name.name, 0, 0, 0);}
			superNodePDUStatus.currentVersion = 1;
			superNodePDUStatus.refreshCount = 0;
			superNodePDUStatus.timeToLive = SYSTEM->addTicks(SYSTEM->getTicks(), SYSTEM->msToTick(GP_SUPERNODE_TIMETOLIVE));
			superNodePDUStatus.superNodeRef = superNode;
		}
		else {
			superNodePDUStatus.currentVersion++;
			superNodePDUStatus.refreshCount = 0;
			superNodePDUStatus.timeToLive = SYSTEM->addTicks(SYSTEM->getTicks(), SYSTEM->msToTick(GP_SUPERNODE_TIMETOLIVE));
			if (SYS_eventTrace == true) { SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_MEDIUM, "Domain_overlap=false", (int *) &superNode->get_myNodeInfo()->nodeId.name.name, 0, 0, 0);}
		};

		centroid.saveDomain(&get_identity(), &superNode->get_identity());
		superNode->update_centroidNode(this);
		superNode->update_liveKeeper(&get_identity());
	}
	else if (centroid.is_stableCentroid() == false && newSuperNode == true) {  // This node is no longer Centroid, save domain and superNode status in case the superNode should be killed.
		if (SYS_eventTrace == true) { SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_MEDIUM, "Retired_stable_centroid", 0, 0, 0, 0);}
		myNodeInfo.domainCenter = false;
		newSuperNode = false;
		oldSNPosFound = false;

		for (i = 0; i < MAX_OLDSUPERNODES && oldSNPosFound == false; i++) {
			if (oldSuperNodeStatus[i] == 0) {
				oldSuperNodeStatus[i] = superNode;
				oldSNPosFound = true;
			}
		}

		centroid.saveDomain(&get_identity(), &superNode->get_identity());

		if (globalNameSpace->check_ifEqual(mySuperNodePDUProvider.name, this->get_identity().name) == true) {  // This test should not be necessary
			superNodePDUStatus.timeToLive = SYSTEM->addTicks(SYSTEM->getTicks(), SYSTEM->msToTick(GP_SUPERNODE_TIMETOLIVE));
			superNode->update_timeToLive(NODE_TIMETOLIVE, &get_identity());
		}

	}
	else if (centroid.is_stableCentroid() == false && newSuperNode == false) {  // This node is not centroid, just check status of SuperNodeInfo

		if (globalNameSpace->check_ifEqual(mySuperNodePDUProvider.name, this->get_identity().name) == true) {
			superNodePDUStatus.timeToLive = SYSTEM->addTicks(SYSTEM->getTicks(), SYSTEM->msToTick(GP_SUPERNODE_TIMETOLIVE));
			superNode->update_timeToLive(NODE_TIMETOLIVE, &get_identity());		
		}
		else if (superNodePDUStatus.timeToLive.tickPoint < SYSTEM->getTicks().tickPoint && superNode != 0) {  // Kill off PDU and domain status, is SuperNode != 0 necessary???
			if (SYS_eventTrace == true) { SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_HIGH, "Killed_supernode_status", (int *) &superNode->get_myNodeInfo()->nodeId.name.name, 0, 0, 0);}
			superNodePDUStatus.currentVersion = superNodePDUStatus.refreshCount = superNodePDUStatus.PDU_TTL = 0;
			superNodePDUStatus.timeToLive.tickPoint = 0;
			superNodePDUStatus.superNodeRef = superNode = 0;
			superNodePDUStatus.nodeInf = 0;
			myOldSuperNodePDUProvider = mySuperNodePDUProvider;
			mySuperNodePDUProvider = this->reset_anotherIdentity();
			centroid.reset_savedDomain();
			centroid.reset_nodeInfDomainLevel();
		};

	}
	else if (centroid.is_stableCentroid() == true && newSuperNode == true) {  // This node is the Centroid and cares for the superNode, just update ttl for superNode, and check whether  domain node set has changed

		if (centroid.get_domainNodeDiffs() > 0) {
			superNodePDUStatus.currentVersion++;
			superNodePDUStatus.refreshCount = 0;
		}

		superNodePDUStatus.timeToLive = SYSTEM->addTicks(SYSTEM->getTicks(), SYSTEM->msToTick(GP_SUPERNODE_TIMETOLIVE));
		superNode->update_timeToLive(NODE_TIMETOLIVE, &get_identity());
	};  // ENDIF centroidStatus

	// Delete any old superNode whose lifetime has expired for which this node once was responsible, and may still be!

	for (i = 0; i < MAX_OLDSUPERNODES; i++) {

		if (oldSuperNodeStatus[i] != 0) {
			
			if (oldSuperNodeStatus[i]->get_timeToLive().tickPoint < SYSTEM->getTicks().tickPoint) {  // The superNode shall be terminated as well as as possibly any old domain associated with it
				oldSuperNodeStatus[i]->Node_delete();
				SYSTEM->req_entityDeletion(&oldSuperNodeStatus[i]->get_identity(), oldSuperNodeStatus[i]);  // Better to let the SYSTEM delete for proper coordination
//				SYSTEM->report_entityDeletion(&get_identity(), &oldSuperNodeStatus[i]->get_identity(), oldSuperNodeStatus[i]->get_myNodeInfo(), 0);
//				delete oldSuperNodeStatus[i];
				oldSuperNodeStatus[i] = 0;
			}
			else if (globalNameSpace->check_ifEqual(oldSuperNodeStatus[i]->get_liveKeeper()->name, get_identity().name) == false) {  // This supernode is now maintained by someone else, shall be removed from the old list
				// Check also if this is the node for which this node is the SN PDU provider, if so this node shall no longer be SN PDU provider
				if (superNode == oldSuperNodeStatus[i] && globalNameSpace->check_ifEqual(mySuperNodePDUProvider.name, get_identity().name) == true) {  // Kill off PDU status, NB!!! Can still be valid status as it is still alive, if this is in the same domain as the Centorid maintaining the SN???
					if (SYS_eventTrace == true) { SYSTEM->eventTrace(&this->get_identity(), &this->get_identity(), SYS_LL_HIGH, "Killed_supernode_status", (int *) &superNode->get_myNodeInfo()->nodeId.name.name, 0, 0, 0);}
					superNodePDUStatus.currentVersion = superNodePDUStatus.refreshCount = superNodePDUStatus.PDU_TTL = 0;
					superNodePDUStatus.timeToLive.tickPoint = 0;
					superNodePDUStatus.superNodeRef = superNode = 0;
					superNodePDUStatus.nodeInf = 0;
					myOldSuperNodePDUProvider = mySuperNodePDUProvider;
					mySuperNodePDUProvider = this->reset_anotherIdentity();
				}

				oldSuperNodeStatus[i] = 0;
			};

		};

	}

};

void Node::printMe(ObjSelector obj) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Node, printMe\n");}
	objPrint = obj;
	SYSTEM->logNode(this, obj);
	objPrint = OBJ_ALL;  // Defaults to print all objects
};	
ostream &operator<<(ostream &stream, Node *no) {
	Entity *enp;
	NodeTopology *nodeTop;
	RemoteNodeTopology *remoteNodeTop;
	SortedTopology *sortedTop;
	Centroid *cen;
	SwitchCore *swCore;
	LinkAbstraction *linkAbst;
	NodeInterface *nodeInf;
	int i;
	ObjSelector obj;
	Identity_s id;

	enp = no;
	stream << enp;
	stream << "Domainlevel: " << no->myNodeInfo.nodeTraits.domainLevel << "\n";

	if (no->myNodeInfo.coreNode == true) {
		stream << "This is a core node.";
	}
	else {
		stream << "This is a super node.";
	};

	if (no->myNodeInfo.domainCenter == true) {
		stream << " This node is the domain centre";
	}

	stream << "\n";

	stream << " Domain radius: " << no->myNodeInfo.domainRadius << "\n";
	stream << "Current position: " << "X: " << no->currentPos.xCoord << " Y: " << no->currentPos.yCoord << " Z: " << no->currentPos.zCoord << "\n";
	id = no->mySuperNodePDUProvider;
	stream << "My SuperNodePDU provider: " << id.type << "/" << id.nickName << "/" << id.name.name;

	if (no->superNode != 0) {
		id = no->superNode->get_identity();
		stream << " Supernode: " << id.type << "/" << id.nickName << "/" << id.name.name;
	}
	else {
		stream << " No Supernode";
	};

	if (no->subNode != 0) {
		id = no->subNode->get_identity();
		stream << " Subnode: " << id.type << "/" << id.nickName << "/" << id.name.name;
	}
	else if (no->myNodeInfo.coreNode == false) {
		stream << " No subnode";
	};

	stream << "\n";

	stream << "Node_objects:\n";

	nodeTop = &no->nodeTopology;
	remoteNodeTop = &no->remoteExtNodeTopology;
	sortedTop = &no->sortedTopology;
	cen = &no->centroid;
	swCore = &no->switchCore;
	linkAbst = &no->linkAbstraction;
	obj = no->objPrint;

	if (obj == OBJ_ALL) {
		stream << swCore << nodeTop << remoteNodeTop << sortedTop << cen; 

		for (i = 0; i < no->currentNoInterfaces; i++) {
			nodeInf = nodeTop->getNext_nodeInterface(false);
			stream << nodeInf;
		}

		nodeTop->getNext_nodeInterface(true);
	
		if (no->myNodeInfo.coreNode == false) {
			stream << linkAbst;
		}

	}
	else {

		switch (obj) {

			case OBJ_NODETOP:
				stream << nodeTop;
				break;

			case OBJ_REMOTETOP:
				stream << remoteNodeTop;
				break;

			case OBJ_SORTEDTOP:
				stream << sortedTop;
				break;

			case OBJ_CENTROID:
				stream << cen;
				break;

			case OBJ_LINKABST:
		
				if (no->myNodeInfo.coreNode == false) {
					stream << linkAbst;
				}

				break;

			case OBJ_SWITCHCORE:
				stream << swCore;

			case OBJ_NODEINF:
		
				for (i = 0; i < no->currentNoInterfaces; i++) {
					nodeInf = nodeTop->getNext_nodeInterface(false);
					stream << nodeInf;
				}

				break;

			default:
				SYSTEM->runtimerror(&no->get_identity(), "ostream", "Invalid_objSelector", SYS_ERR_HARD);

		};

	};

	stream << "End_Node_objects\n";
	return stream;
};
