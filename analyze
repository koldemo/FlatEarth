#include <iostream>
#include <fstream>
#include <string>
#include <new>
using namespace std;

#include "C:\Users\CLONEZILLA\Documents\Visual Studio 2008\Projects\Netcell_test\Netcell_test\definitions.h"

// CLASS ANALYZE FUNCTIONS
void Analyze::Analyze_init(Identity_s *id) {
	int i;

	identity.Identity_init(id);
	lastStoredNodeListItem = lastStoredLinkListItem = -1;
	numberStoredNodeListItems = numberStoredLinkListItems = 0;

	for (i = 0; i < ANA_MAX_NODESHORTLIST; i++) {
		nodeShortList[i].nodeId.type = "-";
	}

	for (i = 0; i < ANA_MAX_LINKSHORTLIST; i++) {
		linkShortList[i].linkId.type = "-";
	}

};

void Analyze::Analyze_delete() {
};

int Analyze::make_plotFile(ifstream &in, ANA_AnalyzeFilter_s analFilter, ofstream &outPlot) {
	// This function reads the output file from the test and formats and filter that output to a plot file to be used by GnuPlot
	string in_string, in_qualifier, in_reportType, in_reportComment, slash, comma;
	Identity_s sourceId, entityId, nodeId, idArray[SYS_MAX_IDARRAY];
	unsigned __int64 tickpoint;
	NodeInfo_s *nodeInfo, *nodeItem;
	int i, colPos, noLines;


	// First find start position for simulation results
	in >> in_string;

	while (in_string != "TESTOUT_SIMULATION:") {
		in >> in_string;
	}

	outPlot << "#1Tickpoint\t\t2NodeCreation\t3LinkCreation\t4NodeDeletion\t5LinkDeletion\t6ProCentroid\t7DemCentroid\t8NewSupernode\t9KilledSN\t10NewStableCent\t11StableCent\t12LostStaCent\t13RetiStaCent\t14DoNodeSetCh\t15RxUpdDoNoSet\t16ChgdSNProv\t17ChgdSelCen\t18NodeInfDoBdr\t19NoInfNoDoBdr\t20DomBordRst\t21ExtNoInfSta\t22ExtNoInfSto\t23ReqEntDelNEx\n";
	noLines = 0;  // Insert above line every 50th row of data.

	// initiate while-loop to read until end of simulation results
	in >> in_string;

	while (in_string != ":END_SIMULATION") {
		
		if (in_string == "T_:") {
			// Read out Tickpoint and the qualifier that follows
			in >> tickpoint >> in_qualifier;

			while (in_qualifier != ":_ET") {
			
				if (in_qualifier == "R_:") {
					// Check what type it is
					in >> in_reportType;

					if (in_reportType == "EventTrace:") {
						//Read out source and entity information
						in >> in_string; // Contains "Source,Entity"
						in >> sourceId.type >> slash >> sourceId.nickName >> slash >> sourceId.name.name >> comma;
						in >> entityId.type >> slash >> entityId.nickName >> slash >> entityId.name.name;
	
						nodeItem = this->find_nodeListItem(&entityId);

						if (nodeItem == 0) {  // Not in short list, go look for it from SYSTEM
							nodeInfo = SYSTEM->get_nodeInfo(&entityId);
							nodeItem = this->store_nodeListItem(nodeInfo);
						}

						if (nodeItem->nodeTraits.domainLevel >= analFilter.highestLevel && nodeItem->nodeTraits.domainLevel <= analFilter.lowestLevel) {  // Check if passing through filter, if yes, store to plotfile
							// Read out report comment
							in >> in_reportComment;
							colPos = this->find_columnPosition_plotFile(in_reportComment);

							if (colPos != -1) {  // -1 would indicate an unknown report comment
								// First put in the tickPoint in plotfile, which makes up the first column
								if (tickpoint < 10000000) {
									outPlot << tickpoint << "\t\t\t";
								}
								else if (tickpoint < 1000000000000000) {
									outPlot << tickpoint << "\t\t";
								}
								else {
									outPlot << tickpoint << "\t";
								};

								// Then add up "?" until column position has been reached
								for (i = 2; i < colPos; i++) {
									outPlot << "?\t\t";
								}

								// Add node id for this event, the superNode id in case of "New_supernode" or "Killed_supernode"
								if (in_reportComment == "New_supernode" || in_reportComment == "Killed_supernode") {
									in >> in_string;  // Read out "I-value:"
									in >> nodeId.name.name;
								}
								else {
									nodeId.name.name = entityId.name.name;
								};

								if (nodeId.name.name < 10000000) {
									outPlot << nodeId.name.name << "\t\t";
								}
								else {
									outPlot << nodeId.name.name << "\t";
								};

								// Then add up "?" until last column
								for (i = colPos+1; i < ANA_MAX_PLOTCOLUMNS; i++) {  // NB! for-loop goes to next last column as first column has number "1".
									outPlot << "?\t\t";
								};

								outPlot << "?\n";  // Last column and with a newline
								noLines++;

								if (noLines == 50) {
									outPlot << "#1Tickpoint\t\t2NodeCreation\t3LinkCreation\t4NodeDeletion\t5LinkDeletion\t6ProCentroid\t7DemCentroid\t8NewSupernode\t9KilledSN\t10NewStableCent\t11StableCent\t12LostStaCent\t13RetiStaCent\t14DoNodeSetCh\t15RxUpdDoNoSet\t16ChgdSNProv\t17ChgdSelCen\t18NodeInfDoBdr\t19NoInfNoDoBdr\t20DomBordRst\t21ExtNoInfSta\t22ExtNoInfSto\t23ReqEntDelNEx\n";
									noLines = 0;
								}

								// Read out until ":_ER" has been reached
								in >> in_string;

								while (in_string != ":_ER") {
									in >> in_string;
								}

							}
							else {  // colPos == -1, have come across an unsupported report comment!!!
								// Read out until ":_ER" has been reached
								in >> in_string;

								while (in_string != ":_ER") {
									in >> in_string;
								}

							};  // ENDIF colPos

						}
						else {  // This report shall be filtered away, read out until ":_ER" has been found
							in >> in_string;

							while (in_string != ":_ER") {
								in >> in_string;
							}

						};

					}
					else {  // plotFile only deals with reports of type "EventTrace", read out until ":_ER" has been found
						in >> in_string;

						while (in_string != ":_ER") {
							in >> in_string;
						}

					};  // ENDIF eventTrace

				}
				else if (in_qualifier == "C_:") {  // Read out until ":_EC" has been found
					in >> in_string;

					while (in_string != ":_EC") {
						in >> in_string;
					}

				}
				else if (in_qualifier == "E_:") {  // Read out until ":_EE" has been found
					in >> in_string;

					while (in_string != ":_EE") {
						in >> in_string;
					}

				}
				else {
					cout << "in_qualifier: " << in_qualifier << "\n";
					SYSTEM->runtimerror(&identity.get_identity(), "make_plotFile", "Unknown_qualifier", SYS_ERR_HARD);
					return(-1);
				};  // ENDIF in_qualifier

				in >> in_qualifier;
			};  // ENDWHILE in_qualifier

		}
		else {
			cout << "in_string: " << in_string << "\n";
			SYSTEM->runtimerror(&identity.get_identity(), "make_plotFile", "Unknown_semantics", SYS_ERR_HARD);
			return(-1);
		}  // ENDIF "T_:"

		in >> in_string;
	}  // ENDWHILE ":END_SIMULATION"

	return(0);
};

int Analyze::analyze_centroid_SN(std::ifstream &in, ANA_AnalyzeFilter_s analFilter, std::ofstream &centroid_SN_table) {
	// This function reads the output file from the test and put a table listing all events related to centroid, domain and superNode events
	string in_string, in_qualifier, in_reportType, in_reportComment, slash, comma;
	Identity_s sourceId, entityId, nodeId, nodeInfId, linkId, idArray[SYS_MAX_IDARRAY];
	unsigned __int64 tickpoint;
	NodeInfo_s *nodeInfo, *nodeItem, *nodeItem2;
	LinkInfo_s *linkInfo, *linkItem;
	int eventIndex, numberNodes, domainLevel;
	float centroidScore;
	bool domainNodeDiff;

	// First find start position for simulation results
	in >> in_string;

	while (in_string != "TESTOUT_SIMULATION:") {
		in >> in_string;
	}

	centroid_SN_table << "Table providing a list of all events related to changes in centroid, domain, and supernode status.\n\n";


	// initiate while-loop to read until end of simulation results
	in >> in_string;

	while (in_string != ":END_SIMULATION") {
		
		if (in_string == "T_:") {
			// Read out Tickpoint and the qualifier that follows
			in >> tickpoint >> in_qualifier;

			int debugCount;
			debugCount = 0;
			while (in_qualifier != ":_ET") {
			
				if (in_qualifier == "R_:") {
					// Check what type it is
					in >> in_reportType;

					if (in_reportType == "EventTrace:") {
						//Read out source and entity information
						in >> in_string; // Contains "Source,Entity"
						in >> sourceId.type >> slash >> sourceId.nickName >> slash >> sourceId.name.name >> comma;
						in >> entityId.type >> slash >> entityId.nickName >> slash >> entityId.name.name;
	
						nodeItem = this->find_nodeListItem(&entityId);

						if (nodeItem == 0) {  // Not in short list, go look for it from SYSTEM
							nodeInfo = SYSTEM->get_nodeInfo(&entityId);
							nodeItem = this->store_nodeListItem(nodeInfo);
						}

						if (nodeItem->nodeTraits.domainLevel >= analFilter.highestLevel && nodeItem->nodeTraits.domainLevel <= analFilter.lowestLevel) {  // Check if passing through filter, if yes, store to file
							// Read out report comment
							in >> in_reportComment;
							eventIndex = this->find_eventIndex_centroid_SN(in_reportComment);

							if (eventIndex != -1) {  // -1 would indicate an unsupported report comment
								// First put in the tickPoint in file, which makes up the first column
								
								if (tickpoint < 10000000) {
									centroid_SN_table << tickpoint << "\t\t\t";
								}
								else if (tickpoint < 1000000000000000) {
									centroid_SN_table << tickpoint << "\t\t";
								}
								else {
									centroid_SN_table << tickpoint << "\t";
								};

								// Add up with eventIndex, the reportComment, and the entity reporting it.
								centroid_SN_table << "(" << eventIndex << ")\t" << in_reportComment << ":\n";
								centroid_SN_table << "Reported by: " << nodeItem->nodeId.type << "/" << nodeItem->nodeId.nickName << "/" << nodeItem->nodeId.name.name << "\n";

								// Add up with any additional information provided as part of the report
								if (eventIndex == 2) { // (reportComment == "Promoted_Centroid")
									in >> in_string >> numberNodes >> in_string >> centroidScore >> in_string >> domainNodeDiff; // Read out "I_value", "F_value", and "B_value"
									centroid_SN_table << "Number of nodes in Domain Node Set: " << numberNodes;
									centroid_SN_table << " Centroid score: " << centroidScore;
									centroid_SN_table << " Domain node difference: " << domainNodeDiff << "\n\n";
									in >> in_string;  // Read out ":_ER"
								}
								else if (eventIndex == 3) { // (reportComment == "Demoted_Centroid")
									in >> in_string >> numberNodes >> in_string >> centroidScore; // Read out "I_value" and "F_value"
									centroid_SN_table << "Number of nodes in Domain Node Set: " << numberNodes;
									centroid_SN_table << " Centroid score: " << centroidScore << "\n\n";
									in >> in_string;  // Read out ":_ER"
								}
								else if (eventIndex == 4 || eventIndex == 5) { // (reportComment == "New_supernode or "Killed_supernode")
									in >> in_string; // Read out "I_value"
									in >> nodeId.name.name;;
									centroid_SN_table << "Supernode name: " << nodeId.name.name << "\n\n";
									in >> in_string;  // Read out ":_ER"
								}
								else if (eventIndex == 6 || eventIndex == 7) { // (reportComment == "Stable_centroid") or "Lost_position_as_stable_centroid"
									centroid_SN_table << "\n";
									in >> in_string; // Read out ":_ER"
								}
								else if (eventIndex == 8 || eventIndex == 9) {  // (reportComment == "Changed_superNodePDU_provider" or "Changed_selected_Centroid")
									in >> in_string;  // Read out idArray, BUT which may not be there in case there is no change to a new procider/Centroid
				
									if (in_string == "idArray:") {  // If not, in_string == ":_ER"
										in >> nodeId.type >> slash >> nodeId.nickName >> slash >> nodeId.name.name;
										nodeItem2 = this->find_nodeListItem(&nodeId);

										if (nodeItem2 == 0) {
											nodeInfo = SYSTEM->get_nodeInfo(&nodeId);
											nodeItem2 = this->store_nodeListItem(nodeInfo);
										}

										centroid_SN_table << nodeId.type << "/" << nodeId.nickName << "/" << nodeId.name.name << "\n\n";
										in >> in_string;  // Read out ":_ER"
									}

								}
								else if (eventIndex == 10 || eventIndex == 11) { // (reportComment == "Node_Interface_has_become_domain_border" or "Node_Interface_is_no_longer_a_domain_border")
									// Read out until "I_value"
									in >> in_string;  // Read out "I_value"
									in >> domainLevel;
									centroid_SN_table << "Domain level: " << domainLevel << "\n";
									// Read out the node interface and the link listed in idArray
									in >> in_string; // Read out "idArray:"
									centroid_SN_table << "Node interface and attached link: ";
									in >> nodeInfId.type >> slash >> nodeInfId.nickName >> slash >> nodeInfId.name.name >> comma;
									in >> linkId.type >> slash >> linkId.nickName >> slash >> linkId.name.name;

									linkItem = this->find_linkListItem(&linkId);

									if (linkItem == 0) {
										linkInfo = SYSTEM->get_linkInfo(&linkId);
										linkItem = this->store_linkListItem(linkInfo);
									}

									centroid_SN_table << nodeInfId.type << "/" << nodeInfId.nickName << "/" << nodeInfId.name.name << " , " << linkId.type << "/" << linkId.nickName << "/" << linkId.name.name << "\n\n";
									in >> in_string;  // Read out ":_ER"
								}
								else if (eventIndex == 12 || eventIndex == 13) { // (reportComment == "Domain_node_set_changed" or "Rcvd_updated_domain_node_set")
									// Read out until "I_value"
									in >> in_string;  // Read out "I_value"
									in >> numberNodes;
									centroid_SN_table << "Number of nodes in domain: " << numberNodes << "\n";
									// Read out all the nodes listed in idArray
									in >> in_string; // Read out "idArray:"
									centroid_SN_table << "Domain node set: ";

									while (in_string != ":_ER") {
										in >> nodeId.type >> slash >> nodeId.nickName >> slash >> nodeId.name.name >> in_string;
										nodeItem2 = this->find_nodeListItem(&nodeId);

										if (nodeItem2 == 0) {
											nodeInfo = SYSTEM->get_nodeInfo(&nodeId);
											nodeItem2 = this->store_nodeListItem(nodeInfo);
										}

										centroid_SN_table << nodeId.type << "/" << nodeId.nickName << "/" << nodeId.name.name << ", ";
									}

									centroid_SN_table << "\n\n";
								};

							}
							else {  // eventIndex == -1, have come across an unsupported report comment!!!
								// Read out until ":_ER" has been reached
								in >> in_string;

								while (in_string != ":_ER") {
									in >> in_string;
								}

							};  // ENDIF colPos

						}
						else {  // This report shall be filtered away, read out until ":_ER" has been found
							in >> in_string;

							while (in_string != ":_ER") {
								in >> in_string;
							}

						};

					}
					else {  // Only deals with reports of type "EventTrace", read out until ":_ER" has been found
						in >> in_string;

						while (in_string != ":_ER") {
							in >> in_string;
						}

					};  // ENDIF eventTrace

				}
				else if (in_qualifier == "C_:") {  // Read out until ":_EC" has been found
					in >> in_string;

					while (in_string != ":_EC") {
						in >> in_string;
					}

				}
				else if (in_qualifier == "E_:") {  // Read out until ":_EE" has been found
					in >> in_string;

					while (in_string != ":_EE") {
						in >> in_string;
					}

				}
				else {
					SYSTEM->runtimerror(&identity.get_identity(), "analyze_centroid_SN", "Unknown_qualifier", SYS_ERR_HARD);
					return(-1);
				};  // ENDIF in_qualifier

				in >> in_qualifier;
			};  // ENDWHILE in_qualifier

		}
		else {
			SYSTEM->runtimerror(&identity.get_identity(), "analyze_centroid_SN", "Unknown_semantics", SYS_ERR_HARD);
			return(-1);
		}  // ENDIF "T_:"

		in >> in_string;
	}  // ENDWHILE ":END_SIMULATION"

	return(0);
};

int Analyze::extract_nodeLogs(std::ifstream &in, ANA_AnalyzeFilter_s analFilter, std::ofstream &nodeLogs) {
	// Extract all node logs from the in file according to the analyze filter and put all those logs into nodeLogs
	string in_string, in_string2, extName, slash, in_qualifier, in_reportType;
	Identity_s nodeId;
	unsigned int domLevel, objSelector;
	unsigned __int64 tickpoint;
	bool logged;
	string input;

	// First find start position for simulation results
	in >> in_string;

	while (in_string != "TESTOUT_SIMULATION:") {
		in >> in_string;
	}

	nodeLogs << "NODE LOGS\n";

	// initiate while-loop to read until end of simulation results
	in >> in_string;

	while (in_string != ":END_SIMULATION") {

		if (in_string == "T_:") {
			logged = false;
			// Read out Tickpoint and the qualifier that follows
			in >> tickpoint >> in_qualifier;

			while (in_qualifier != ":_ET") {

				if (in_qualifier == "R_:") {

					// Check what type it is
					in >> in_reportType;

					if (in_reportType == "Node_Log:") {
						in >> objSelector;

						if((ObjSelector) objSelector == OBJ_ALL || analFilter.selector == OBJ_ALL || (ObjSelector) objSelector == analFilter.selector) {  // If not, this node log shall be skipped
							logged = true;
							//Read out identity information and domainlevel
							getline(in, in_string);  // This one reads out endl
							getline(in, in_string);   // Identity info and Time to live
							in >> in_string2 >> domLevel;

							if ((DomainLevel) domLevel >= analFilter.highestLevel && (DomainLevel) domLevel <= analFilter.lowestLevel) {  // Check if passing through filter, if yes, store to plotfile
								nodeLogs << "T_: " << tickpoint << " R_: " << "Node_Log: " << objSelector << "\n";
								nodeLogs << in_string << "\n" << in_string2 << " " << domLevel << "\n";
								// Read out until "Node_objects:"
								getline(in, in_string);  // This one reads out endl
								getline(in, in_string);

								while (in_string != "Node_objects:") {
									nodeLogs << in_string << "\n";
									getline(in, in_string);
								}

								nodeLogs << "Node_objects:\n";

								// Check analyze filter wrt to what object shall be printed (possibly all);

								switch (analFilter.selector) {

									case OBJ_ALL:
										//Read everything until "End_Node_objects"
										getline (in, in_string);

										while (in_string != "End_Node_objects") {
											nodeLogs << in_string << "\n";
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										break;

									case OBJ_NODETOP:
										// First read everyting until "NodeTopology_status:"
										getline(in, in_string);

										while (in_string != "NodeTopology_Status:") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										// Read out and transfer to nodeLogs until "End_NodeTopology_status"
										getline(in, in_string);

										while (in_string != "End_NodeTopology_Status") {
											nodeLogs << in_string << "\n";
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										//Read until "End_Node_objects"
										getline(in, in_string);

										while (in_string != "End_Node_objects") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										break;

									case OBJ_REMOTETOP:
										// First read everyting until "RemoteNodeTopology_status:"
										getline(in, in_string);

										while (in_string != "RemoteNodeTopology_Status:") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										// Read out and transfer to nodeLogs until "End_RemoteNodeTopology_status"
										getline(in, in_string);

										while (in_string != "End_RemoteNodeTopology_Status") {
											nodeLogs << in_string << "\n";
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										//Read until "End_Node_objects"
										getline(in, in_string);

										while (in_string != "End_Node_objects") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										break;

									case OBJ_SORTEDTOP:
										// First read everyting until "SortedTopology_status:"
										getline(in, in_string);

										while (in_string != "SortedTopology_Status:") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										// Read out and transfer to nodeLogs until "End_SortedTopology_status"
										getline(in, in_string);

										while (in_string != "End_SortedTopology_Status") {
											nodeLogs << in_string << "\n";
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										//Read until "End_Node_objects"
										getline(in, in_string);

										while (in_string != "End_Node_objects") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										break;

									case OBJ_CENTROID:
										// First read everyting until "Centroid_status:"
										getline(in, in_string);

										while (in_string != "Centroid_Status:") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										// Read out and transfer to nodeLogs until "End_Centroid_status"
										getline(in, in_string);

										while (in_string != "End_Centroid_Status") {
											nodeLogs << in_string << "\n";
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										//Read until "End_Node_objects"
										getline(in, in_string);

										while (in_string != "End_Node_objects") {
											getline(in, in_string);
										}

										nodeLogs << in_string << "\n";

										break;

									case OBJ_LINKABST:
			
										break;

									case OBJ_SWITCHCORE:

										break;

									case OBJ_NODEINF:		

										break;
	
									default:
										SYSTEM->runtimerror(&identity.get_identity(), "extract_nodeLogs", "Invalid_objSelector", SYS_ERR_HARD);
										return(-1);
								};
	
								// Read out intil "End_Node_Log" has been reached, store in nodeLogs
								getline (in, in_string);

								while (in_string != "End_Node_Log") {
									nodeLogs << in_string << "\n";
									getline(in, in_string);
								}

								nodeLogs << in_string << "\n";
	
								// Read out until ":_ER" has been reached, store in nodeLogs
								in >> in_string;

								while (in_string != ":_ER") {
									nodeLogs << in_string;
									in >> in_string;
								}

								nodeLogs << in_string << " ";

							}
							else {  // This report shall be filtered away, read out until ":_ER" has been found
								in >> in_string;

								while (in_string != ":_ER") {
									in >> in_string;
								}

							};

						}
						else {
						}
					}
					else {  // extract_nodeLogs only deals with reports of type "Node_Log", read out until ":_ER" has been found
						in >> in_string;

						while (in_string != ":_ER") {
							in >> in_string;
						}

					};  // ENDIF eventTrace

				}
				else if (in_qualifier == "C_:") {  // Read out until ":_EC" has been found
					in >> in_string;

					while (in_string != ":_EC") {
						in >> in_string;
					}

				}
				else if (in_qualifier == "E_:") {  // Read out until ":_EE" has been found
					in >> in_string;

					while (in_string != ":_EE") {
						in >> in_string;
					}

				}
				else {
					SYSTEM->runtimerror(&identity.get_identity(), "extract_nodeLogs", "Unknown_qualifier", SYS_ERR_HARD);
					return(-1);
				};  // ENDIF in_qualifier

				in >> in_qualifier;
			};  // ENDWHILE in_qualifier

			if (logged == true) {
				nodeLogs << in_qualifier << "\n\n";
				logged = false;  // Reset
			}

		}
		else {
			SYSTEM->runtimerror(&identity.get_identity(), "make_plotFile", "Unknown_semantics", SYS_ERR_HARD);
			return(-1);
		}  // ENDIF "T_:"

		in >> in_string;
	}  // ENDWHILE ":END_SIMULATION"

	return(0);
};

NodeInfo_s *Analyze::store_nodeListItem(NodeInfo_s *nodeInfo) {
	// Please note that it will overwrite any previously stored nodeListItems if and when the list becomes full, i.e. it works pretty much as a cash.
	lastStoredNodeListItem++;
	lastStoredNodeListItem &= (ANA_MAX_NODESHORTLIST-1);
	nodeShortList[lastStoredNodeListItem] = *nodeInfo;
	numberStoredNodeListItems++;  // Will continue to increment even if it goes beyond ANA_MAX_NODESHORTLIST
	return(&nodeShortList[lastStoredNodeListItem]);
};

LinkInfo_s *Analyze::store_linkListItem(LinkInfo_s *linkInfo) {
	// Please note that it will overwrite any previously stored nodeListItems if and when the list becomes full, i.e. it works pretty much as a cash.
	lastStoredLinkListItem++;
	lastStoredLinkListItem &= (ANA_MAX_LINKSHORTLIST-1);
	linkShortList[lastStoredLinkListItem] = *linkInfo;
	numberStoredLinkListItems++;  // Will continue to increment even if it goes beyond ANA_MAX_LINKSHORTLIST
	return(&linkShortList[lastStoredLinkListItem]);
};

NodeInfo_s *Analyze::find_nodeListItem(Identity_s *nodeId) {
	// It starts the search from the most rececently stored noedListItem and then go backwards.
	int storedNodeListItem;
	bool nodeListItemFound;

	storedNodeListItem = lastStoredNodeListItem;
	nodeListItemFound = false;

	if (numberStoredNodeListItems < ANA_MAX_NODESHORTLIST) {  // List still not full

		while (storedNodeListItem != -1 && nodeListItemFound == false) {

			if (globalNameSpace->check_ifEqual(nodeShortList[storedNodeListItem].nodeId.name, nodeId->name) == true) {
				nodeListItemFound = true;
			}
			else {
				storedNodeListItem--;
			};

		}

	}
	else {

		if (globalNameSpace->check_ifEqual(nodeShortList[storedNodeListItem].nodeId.name, nodeId->name) == true) {
			nodeListItemFound = true;
		}

		while (storedNodeListItem != lastStoredNodeListItem && nodeListItemFound == false) {

			if (globalNameSpace->check_ifEqual(nodeShortList[storedNodeListItem].nodeId.name, nodeId->name) == true) {
				nodeListItemFound = true;
			}
			else {
				storedNodeListItem--;

				if (storedNodeListItem == -1) {
					storedNodeListItem = ANA_MAX_NODESHORTLIST-1;
				}

			};

		}

	};

	if (nodeListItemFound == true) {
		return(&nodeShortList[storedNodeListItem]);
	}
	else {
		return(0);
	};

};

LinkInfo_s *Analyze::find_linkListItem(Identity_s *linkId) {
	// It starts the search from the most rececently stored noedListItem and then go backwards.
	int storedLinkListItem;
	bool linkListItemFound;

	storedLinkListItem = lastStoredLinkListItem;
	linkListItemFound = false;

	if (numberStoredLinkListItems < ANA_MAX_LINKSHORTLIST) {  // List still not full

		while (storedLinkListItem != -1 && linkListItemFound == false) {

			if (globalNameSpace->check_ifEqual(linkShortList[storedLinkListItem].linkId.name, linkId->name) == true) {
				linkListItemFound = true;
			}
			else {
				storedLinkListItem--;
			};

		}

	}
	else {

		if (globalNameSpace->check_ifEqual(linkShortList[storedLinkListItem].linkId.name, linkId->name) == true) {
			linkListItemFound = true;
		}

		while (storedLinkListItem != lastStoredLinkListItem && linkListItemFound == false) {

			if (globalNameSpace->check_ifEqual(linkShortList[storedLinkListItem].linkId.name, linkId->name) == true) {
				linkListItemFound = true;
			}
			else {
				storedLinkListItem--;

				if (storedLinkListItem == -1) {
					storedLinkListItem = ANA_MAX_LINKSHORTLIST-1;
				}

			};

		}

	};

	if (linkListItemFound == true) {
		return(&linkShortList[storedLinkListItem]);
	}
	else {
		return(0);
	};

};

int Analyze::find_columnPosition_plotFile(std::string reportComment) {

	if (reportComment == "Report_of_node_creation") {
		return(2);
	}
	else if (reportComment == "Report_of_link_creation") {
		return(3);
	}
	else if (reportComment == "Report_of_node_deletion") {
		return(4);
	}
	else if (reportComment == "Report_of_link_deletion") {
		return(5);
	}
	else if (reportComment == "Promoted_Centroid") {
		return(6);
	}
	else if (reportComment == "Demoted_Centroid") {
		return(7);
	}
	else if (reportComment == "New_supernode") {
		return(8);
	}
	else if (reportComment == "Killed_supernode_status") {
		return(9);
	}
	else if (reportComment == "New_stable_centroid") {
		return(10);
	}
	else if (reportComment == "Stable_centroid") {
		return(11);
	}
	else if (reportComment == "Lost_position_as_stable_centroid") {
		return(12);
	}
	else if (reportComment == "Retired_stable_centroid") {
		return(13);
	}
	else if (reportComment == "Domain_node_set_changed") {
		return(14);
	}
	else if (reportComment == "Rcvd_updated_domain_node_set") {
		return(15);
	}
	else if (reportComment == "Changed_superNodePDU_provider") {
		return(16);
	}
	else if (reportComment == "Changed_selected_Centroid") {
		return(17);
	}
	else if (reportComment == "Node_Interface_has_become_domain_border") {
		return(18);
	}
	else if (reportComment == "Node_Interface_is_no_longer_a_domain_border") {
		return(19);
	}
	else if (reportComment == "Domain_borders_reset") {
		return(20);
	}
	else if (reportComment == "Ext_nodeinterface_started") {
		return(21);
	}
	else if (reportComment == "Ext_nodeinterface_stopped") {
		return(22);
	}
	else if (reportComment == "Request_of_entity_deletion_(not_executed)") {
		return(23);
	}
	else {
		return(-1);
	};

};

int Analyze::find_eventIndex_centroid_SN(std::string reportComment) {

	if (reportComment == "Promoted_Centroid") {
		return(2);
	}
	else if (reportComment == "Demoted_Centroid") {
		return(3);
	}
	else if (reportComment == "New_supernode") {
		return(4);
	}
	else if (reportComment == "Killed_supernode_status") {
		return(5);
	}
	else if (reportComment == "Stable_centroid") {
		return(6);
	}
	else if (reportComment == "Lost_position_as_stable_centroid") {
		return(7);
	}
	else if (reportComment == "Changed_superNodePDU_provider") {
		return(8);
	}
	else if (reportComment == "Changed_selected_Centroid") {
		return(9);
	}
	else if (reportComment == "Node_Interface_has_become_domain_border") {
		return(10);
	}
	else if (reportComment == "Node_Interface_is_no_longer_a_domain_border") {
		return(11);
	}
	else if (reportComment == "Domain_node_set_changed") {
		return(12);
	}
	else if (reportComment == "Rcvd_updated_domain_node_set") {
		return(13);
	}
	else {
		return(-1);
	};

};
