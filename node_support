#include <iostream>
#include <string>
#include <new>
using namespace std;

#include "C:\Users\CLONEZILLA\Documents\Visual Studio 2008\Projects\Netcell_test\Netcell_test\definitions.h"

// CLASS CENTROID FUNCTIONS
void Centroid::Centroid_init(Identity_s *id, Node *nRef, SortedTopology *sortTopRef, RemoteNodeTopology *remTopRef, NodeTopology *nodeTopRef, int domainRadius) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, init\n");}

	identity.Identity_init(id);
	stableCentroid = false;
	domainNodeDiffs = 0;
	nodeRef = nRef;
	sortedTopRef = sortTopRef;
	remoteTopRef = remTopRef;
	nodeTopologyRef = nodeTopRef;

	// Create first centroid item, which is always this node
	try {
		firstCentroidItem = new RemoteCentroidItem_s;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&identity.get_identity(), "Centroid_init","allocation_failure", SYS_ERR_HARD);
	}

	firstCentroidItem->previousItem = firstCentroidItem->nextItem = 0;
	firstCentroidItem->nodeInf = 0; // Not applicable
	firstCentroidItem->refreshCount = 0;
	firstCentroidItem->reissueCount = 0;
	firstCentroidItem->timeToLive.tickPoint = 0;  // Will not be checked
	firstCentroidItem->centroidInfo.centroidStatus = NOT_CENTROID;
	firstCentroidItem->centroidInfo.domainRadius = domainRadius;
	firstCentroidItem->centroidInfo.currentCentroid = identity.reset_anotherIdentity();
	firstCentroidItem->centroidInfo.numberNodes = 0;
	firstCentroidItem->centroidInfo.origNode = *(nodeRef->get_myNodeInfo());
	firstCentroidItem->centroidInfo.score = -1;
	firstCentroidItem->centroidInfo.version = 1;
	firstCentroidItem->tierNodeItem.tier = 0;  // This node is always in the innermost tier
	firstCentroidItem->tierNodeItem.remoteNodeTop = remoteTopRef->get_remoteTopItem(&(nodeRef->get_myNodeInfo()->nodeId));
	nextCentroidItem = firstCentroidItem;
	currentCentroid = oldCentroid = 0;
	nextDomainNodeIndex = 0;

	stableCentroid = false;
	stableIterations = 0;

	oldDomain.oldDomainSize = 0;
	oldDomain.superNodeId = oldDomain.centroidNodeId = identity.reset_anotherIdentity();
	currentNumberCentroids = 1;
	signature = 0;
	networkNeighborhood = nodeRef->get_myNodeInfo()->domainRadius*2 + 1;
	centroidTicks = SYSTEM->msToTick(CENTROIDS_INTERVAL);
	ticksDiff.tickPoint = 0;
	lastTicksRead = SYSTEM->getTicks();

	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(centroidTicks), CB_CENTROID, 0);

};

void Centroid::Centroid_delete() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, delete\n");}

	RemoteCentroidItem_s *centroidItem, *oldCentroidItem;

	centroidItem = firstCentroidItem;

	while (centroidItem != 0) {
		oldCentroidItem = centroidItem;
		centroidItem = centroidItem->nextItem;
		delete oldCentroidItem;
	};

	if (callbackRef != -1) {
		SYSTEM->delete_ticksQueueEvent(callbackRef);
		callbackRef = -1;
		cout << "Centroids Callback\n";
	}

};



CentroidItem_s *Centroid::get_centroidStatus(Identity_s *id) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_centroidStatus\n");}
	RemoteCentroidItem_s *remCentroidItem;

	remCentroidItem = this->find_remoteCentroidItem(id);
	
	if (remCentroidItem != 0) {
		return(&remCentroidItem->centroidInfo);
	}
	else {
		return(0);
	};

};

float Centroid::get_centroidScore() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_centroidScore\n");}
	return(firstCentroidItem->centroidInfo.score);
};


int Centroid::get_netNeighborhood() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_netNeighborhood\n");}
	return (networkNeighborhood);
};

int Centroid::update_centroidStatus(NodeInterface *nodeInf, CentroidInfo_s *centroidInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, update_centroidStatus\n");}
	RemoteCentroidItem_s *remoteCentroidItem;
	ReissueInfo_s reissueInfo;
	int i;
	Identity_s idArray[MAX_DOMAINSIZE+1];  // Used for reporting/debugging

	remoteCentroidItem = find_remoteCentroidItem(&centroidInfo->origNode.nodeId);

	if (remoteCentroidItem == 0 && centroidInfo->msgType == CENTROID) { // This is a new centroid item
		add_remoteCentroidItem(nodeInf, centroidInfo);

		// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received
		if (centroidInfo->PDU_TTL > 0) {
			this->resend_PDU(nodeInf, centroidInfo);
		}  

	}
	else if (centroidInfo->msgType == CENTROID_REFRESH) { // Check whether a reissueing might be needed

		if (remoteCentroidItem == 0 || remoteCentroidItem->centroidInfo.version != centroidInfo->version) {
			reissueInfo.initialized = true;
			reissueInfo.processed = false;
			reissueInfo.issueNode = centroidInfo->origNode.nodeId;
			reissueInfo.reissueMsg = CENTROID;
			reissueInfo.version = centroidInfo->version;
			reissueInfo.refreshCount = centroidInfo->refreshCount;
			this->nodeRef->reissueMsgMgmt(nodeInf, &reissueInfo);
		}
		else { // A "normal" refresh

			if (centroidInfo->refreshCount > remoteCentroidItem->refreshCount) { // This is not a duplicate
				remoteCentroidItem->nodeInf = nodeInf;
				remoteCentroidItem->PDU_TTL = centroidInfo->PDU_TTL;
				remoteCentroidItem->timeToLive = centroidInfo->timeToLive;
				remoteCentroidItem->centroidInfo.centroidStatus = centroidInfo->centroidStatus;
				remoteCentroidItem->centroidInfo.version = centroidInfo->version;  // Should not be necessary, i.e. should be the same version.
				remoteCentroidItem->refreshCount = centroidInfo->refreshCount;
				
				// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received
				if (centroidInfo->PDU_TTL > 0) {
					this->resend_PDU(nodeInf, centroidInfo);
				}; // ENDIF PDU_TTL

			}
			else if (centroidInfo->refreshCount == remoteCentroidItem->refreshCount && centroidInfo->PDU_TTL > remoteCentroidItem->PDU_TTL) {  // This is a duplicate however recieved with a higher TTL which needs to be re-distributed to ensure proper dissemination
				// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received
				if (centroidInfo->PDU_TTL > 0) {
					this->resend_PDU(nodeInf, centroidInfo);
				}; // ENDIF PDU_TTL

				remoteCentroidItem->PDU_TTL = centroidInfo->PDU_TTL;
				remoteCentroidItem->nodeInf = nodeInf;
			};  // ENDIF check for duplicates

		};  // Else check for reissueing

	}
	else if (centroidInfo->msgType == CENTROID) {
		// Check whether received PDU is a duplicate of an already received PDU. If yes, it should be silently dropped.
		if (centroidInfo->version > remoteCentroidItem->centroidInfo.version) { // This is not a duplicate.
			remoteCentroidItem->nodeInf = nodeInf;
			remoteCentroidItem->PDU_TTL = centroidInfo->PDU_TTL;
			remoteCentroidItem->timeToLive = centroidInfo->timeToLive;
			remoteCentroidItem->refreshCount = 0;
			remoteCentroidItem->centroidInfo.score = centroidInfo->centroidScore;
			remoteCentroidItem->centroidInfo.version = centroidInfo->version;
			remoteCentroidItem->centroidInfo.origNode = centroidInfo->origNode;
			remoteCentroidItem->centroidInfo.centroidStatus = centroidInfo->centroidStatus;
			remoteCentroidItem->centroidInfo.domainRadius = centroidInfo->domainRadius;
			remoteCentroidItem->centroidInfo.currentCentroid = centroidInfo->currentCentroid;
			remoteCentroidItem->centroidInfo.numberNodes = centroidInfo->numberNodes;

			for (i = 0; i < centroidInfo->numberNodes; i++) {
				remoteCentroidItem->centroidInfo.domainNodes[i] = centroidInfo->domainNodes[i];
			};

			// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received
			if (centroidInfo->PDU_TTL > 0) {
				this->resend_PDU(nodeInf, centroidInfo);
			};

			if (SYS_eventTrace == true) {

				if (currentCentroid != 0) {

					if (globalNameSpace->check_ifEqual(currentCentroid->centroidInfo.origNode.nodeId.name, centroidInfo->origNode.nodeId.name) == true) {

						if (currentCentroid->centroidInfo.numberNodes != centroidInfo->numberNodes) {
							
							for (i = 0; i < firstCentroidItem->centroidInfo.numberNodes; i++) {
								idArray[i] = firstCentroidItem->centroidInfo.domainNodes[i].domainNodeId;
							}

							idArray[i] = identity.reset_anotherIdentity();
							SYSTEM->eventTrace(&identity.get_identity(), &this->nodeRef->get_identity(), SYS_LL_MEDIUM, "Rcvd_updated_domain_node_set", (int *) &centroidInfo->numberNodes, 0, 0, idArray);
						}

					}

				}

			}  // ENDIF SYS_eventTrace


		}
		else if (centroidInfo->version == remoteCentroidItem->centroidInfo.version && centroidInfo->PDU_TTL > remoteCentroidItem->PDU_TTL) { // This is a duplicate however recieved with a higher TTL which needs to be re-distributed to ensure proper dissemination
				// Resend onto all other interfaces, if PDU_TTL > 0, except for the one at which the PDU was received. This also takes of the case of resending a reissueing request received with a higher TTL
			if (centroidInfo->PDU_TTL > 0) {
				this->resend_PDU(nodeInf, centroidInfo);
			};

			remoteCentroidItem->PDU_TTL = centroidInfo->PDU_TTL;
			remoteCentroidItem->nodeInf = nodeInf;
		}
		else if (centroidInfo->version == remoteCentroidItem->centroidInfo.version && centroidInfo->PDU_TTL > remoteCentroidItem->PDU_TTL) { // This is a reissueing request, AND also to be used as a refresh
			remoteCentroidItem->nodeInf = nodeInf;
			remoteCentroidItem->PDU_TTL = centroidInfo->PDU_TTL;
			remoteCentroidItem->timeToLive = centroidInfo->timeToLive;
			remoteCentroidItem->centroidInfo.centroidStatus = centroidInfo->centroidStatus;

			if (centroidInfo->PDU_TTL > 0) {
				this->resend_PDU(nodeInf, centroidInfo);
			};

		};  // ENDIF check for duplicates

	};  // ENDIF msgType
			
	return (0);
};

int Centroid::resend_PDU(NodeInterface *nodeInf, CentroidInfo_s *centroidInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, resend_PDU\n");}
	GenericPDU_s *pdu;
	MsgBody_Centroid_s *centroidBody;
	MsgBody_CentroidRefresh_s *centroidRefreshBody;
	NodeInterface *localNodeInf;
	int i;

	localNodeInf = nodeTopologyRef->getNext_nodeInterface(false);
			
	while (localNodeInf != 0) {

		if (nodeInf != localNodeInf && localNodeInf->isExtInterfaceRunning() == true) {
			try {
				pdu = new GenericPDU_s;

				if (centroidInfo->msgType == CENTROID) {
					centroidBody = new MsgBody_Centroid_s;
				}
				else {
					centroidRefreshBody = new MsgBody_CentroidRefresh_s;
				}

			} catch (bad_alloc xa) {
				SYSTEM->runtimerror(&identity.get_identity(), "resend_PDU", "memory_allocation_failure", SYS_ERR_HARD);
				return (-1);
			}

			pdu->header.msgType = centroidInfo->msgType;
			pdu->header.PDU_TTL = centroidInfo->PDU_TTL;
			pdu->header.numberDest = 0;
			pdu->protTraceRef = centroidInfo->protTraceRef;

			if (centroidInfo->msgType == CENTROID) {
				pdu->header.PDU_size = sizeof(GenericPDU_Centroid_s);
				centroidBody->version = centroidInfo->version;
				centroidBody->reissue = centroidInfo->reissue;
				centroidBody->sourceNode = centroidInfo->origNode;
				centroidBody->centroidStatus = centroidInfo->centroidStatus;
				centroidBody->centroidScore = centroidInfo->centroidScore;
				centroidBody->domainRadius = centroidInfo->domainRadius;
				centroidBody->currentCentroid = centroidInfo->currentCentroid;
				pdu->msgBody.centroidBody = centroidBody;
				pdu->msgBody.centroidBody->numberNodes = centroidInfo->numberNodes;				

				for (i = 0; i < centroidInfo->numberNodes; i++) {
					pdu->msgBody.centroidBody->domainNodes[i] = centroidInfo->domainNodes[i];
				};

			}
			else {  // A refresh
				pdu->header.PDU_size = sizeof(GenericPDU_CentroidRefresh_s);
				centroidRefreshBody->version = centroidInfo->version;
				centroidRefreshBody->refreshCount = centroidInfo->refreshCount;
				centroidRefreshBody->sourceNode = centroidInfo->origNode;
				centroidRefreshBody->centroidStatus = centroidInfo->centroidStatus;
				centroidRefreshBody->centroidScore = centroidInfo->centroidScore;
				pdu->msgBody.centroidRefreshBody = centroidRefreshBody;
			};


			localNodeInf->send_PDU(INF_EXTERNAL, pdu);
		}

		localNodeInf = nodeTopologyRef->getNext_nodeInterface(false);
	}  // ENDWHILE localNodeInf

	return(0);
};

int Centroid::reissue_centroidStatus(NodeInterface *nodeInf, ReissueInfo_s *reissueInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, reissue_centroidStatus\n");}
	// Increase reissueCount
	firstCentroidItem->reissueCount++;
	return(0);
};

int Centroid::add_remoteCentroidItem(NodeInterface *nodeInf, CentroidInfo_s *centroidInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, add_remoteCentroid\n");}

	RemoteCentroidItem_s *remCentroidItem, *lastRemCentroidItem, *newRemCentroidItem;
	int i;

	// Find last item in list
	remCentroidItem = firstCentroidItem;

	while (remCentroidItem != 0) {
		lastRemCentroidItem = remCentroidItem;
		remCentroidItem = remCentroidItem->nextItem;
	};

	try {
		newRemCentroidItem = new RemoteCentroidItem_s;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&identity.get_identity(), "add_remoteCentroidItem","allocation_failure", SYS_ERR_HARD);
		return(-1);
	}

	newRemCentroidItem->nodeInf = nodeInf;
	newRemCentroidItem->refreshCount = 0;
	newRemCentroidItem->timeToLive = centroidInfo->timeToLive;
	newRemCentroidItem->tierNodeItem.tier = 0;
	newRemCentroidItem->tierNodeItem.remoteNodeTop = 0;  // These values are updated when doing the consistency check
	newRemCentroidItem->centroidInfo.version = centroidInfo->version;
	newRemCentroidItem->centroidInfo.origNode = centroidInfo->origNode;
	newRemCentroidItem->centroidInfo.centroidStatus = centroidInfo->centroidStatus;
	newRemCentroidItem->centroidInfo.currentCentroid = centroidInfo->currentCentroid;
	newRemCentroidItem->centroidInfo.domainRadius = centroidInfo->domainRadius;
	newRemCentroidItem->centroidInfo.score = centroidInfo->centroidScore;
	newRemCentroidItem->centroidInfo.numberNodes = centroidInfo->numberNodes;

	if (centroidInfo->centroidStatus == I_CENTROID || centroidInfo->centroidStatus == UNHOMED_CENTROID) {  // This is a centroid, copy the list of nodes being part of the domain

		for (i = 0; i < centroidInfo->numberNodes; i++) {
			newRemCentroidItem->centroidInfo.domainNodes[i] = centroidInfo->domainNodes[i];
		}

	};

	lastRemCentroidItem->nextItem = newRemCentroidItem;
	newRemCentroidItem->previousItem = lastRemCentroidItem;
	newRemCentroidItem->nextItem = 0;
	currentNumberCentroids++;

	return(0);
};

bool Centroid::is_stableCentroid() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, is_stableCentroid\n");}
	return(stableCentroid);
};

RemoteCentroidItem_s *Centroid::find_remoteCentroidItem(Identity_s *id) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, find_remoteCentroidItem\n");}
	RemoteCentroidItem_s *centroidItem;
	bool inList;

	centroidItem = firstCentroidItem;
	inList = false;

	while (centroidItem != 0 && inList == false) {
		
		if (globalNameSpace->check_ifEqual(centroidItem->centroidInfo.origNode.nodeId.name, id->name) == true) {  // A centroidItem exists for this node
			inList = true;
		}
		else {
			centroidItem = centroidItem->nextItem;
		};

	};

	return (centroidItem);

};

RemoteCentroidItem_s *Centroid::getNext_remoteCentroidItem(bool reset) {  // This function should run until it returns a zero pointer
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, getNext_remoteCentroidItem\n");}
	RemoteCentroidItem_s *currentCentroidItem;

	if (nextCentroidItem == 0 || reset == true) {
		nextCentroidItem = firstCentroidItem;
		return(0);
	}
	else {
		currentCentroidItem = nextCentroidItem;
		nextCentroidItem = nextCentroidItem->nextItem;
		return(currentCentroidItem);
	};

};

RemoteTopologyItem_s *Centroid::getNext_domainNode(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, getNext_domainNode\n");}
	RemoteTopologyItem_s *currentDomainNode;
	RemoteCentroidItem_s *centroid;

	if (firstCentroidItem->centroidInfo.centroidStatus == UNHOMED_CENTROID) {
		centroid = firstCentroidItem;
	}
	else {
		centroid = currentCentroid;
	};

	if (centroid != 0) {
	
		if (nextDomainNodeIndex == centroid->centroidInfo.numberNodes || reset == true) {
			nextDomainNodeIndex = 0;
			return(0);
		}
		else {
			currentDomainNode = this->find_remoteCentroidItem(&centroid->centroidInfo.domainNodes[nextDomainNodeIndex].domainNodeId)->tierNodeItem.remoteNodeTop;
			nextDomainNodeIndex++;
			return(currentDomainNode);
		};

	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "getNext_domainNode", "No_existing_Centroid", SYS_ERR_SOFT);
		return(0);
	};

};

Identity_s Centroid::getNext_domainNodeId(bool reset) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, getNext_domainNodeId\n");}
	Identity_s currentDomainNodeId;
	RemoteCentroidItem_s *centroid;

	if (firstCentroidItem->centroidInfo.centroidStatus == UNHOMED_CENTROID) {
		centroid = firstCentroidItem;
	}
	else {
		centroid = currentCentroid;
	};

	if (centroid != 0) {
	
		if (nextDomainNodeIndex == centroid->centroidInfo.numberNodes || reset == true) {
			nextDomainNodeIndex = 0;
			currentDomainNodeId = identity.reset_anotherIdentity();
			return(currentDomainNodeId);
		}
		else {
			currentDomainNodeId = centroid->centroidInfo.domainNodes[nextDomainNodeIndex].domainNodeId;
			nextDomainNodeIndex++;
			return(currentDomainNodeId);
		};

	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "getNext_domainNodeId", "No_existing_Centroid", SYS_ERR_SOFT);
		currentDomainNodeId = identity.reset_anotherIdentity();
		return(currentDomainNodeId);
	};

};

int Centroid::check_topologyConsistency() {  // Check that all centroids have a matching node in SortedTopology
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, check_topologyConsistency\n");}
	RemoteCentroidItem_s *centroidItem;
	TierNodeItem_s tierNodeItem;
	bool notInTopology;

	notInTopology = false;

	if (sortedTopRef->get_currentNumberTierItems() == currentNumberCentroids) {
		centroidItem = firstCentroidItem->nextItem;  // Skip the first node which is this node

		while (centroidItem != 0) {
			tierNodeItem = sortedTopRef->find_tierNodeItem(&(centroidItem->centroidInfo.origNode.nodeId));

			if (tierNodeItem.tier == 0) { // There is no matching node
				notInTopology = true;
				centroidItem->tierNodeItem.tier = 0;
				centroidItem->tierNodeItem.remoteNodeTop = 0;
			}
			else {
				centroidItem->tierNodeItem = tierNodeItem;
			};

			centroidItem = centroidItem->nextItem;
		};

	}
	else {
		notInTopology = true;
	};

/* As not all nodes may need to participate in the Centroid protocol, complete consistency between Centroids and RemoteNodeTopology is not required
This also means that Centroids must be within the distance/coverage of the Topology protocol
NB!!! Current working assumption is that all of them participate in the Centroid protocol
	if (currentNumberCentroids != remoteTopRef->get_currentNumberNodeTopologies()) {  // If number of nodes are different it also indicates inconsistency
		return(-1);
	}
*/

	if (notInTopology == true) {
		return(-1);
	}
	else {
		return(0);
	};

};

float Centroid::calculate_centroidScore() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, calculate_centroidScore\n");}
	RemoteCentroidItem_s *centroidItem;
	float score;
	int i;


	centroidItem = firstCentroidItem->nextItem;  // Skip first one as that is this node
	score = 0;
	i = 0;

	while (centroidItem != 0) {
		score += (float) centroidItem->tierNodeItem.tier;
		i++;
		centroidItem = centroidItem->nextItem;
	};

	if (i > 0) {
		score = score/(float) i;
	}
	else {
		score = -1;
	};

	return(score);
};

int Centroid::calculate_centroidSignature() {  // This is to determine whether a topological change has occcured
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, calculate_centroidSignature\n");}
	RemoteCentroidItem_s *centroidItem;
	int signature;

	centroidItem = firstCentroidItem->nextItem;  // Skip first one as that is this node
	signature = 0;

	while (centroidItem != 0) {
		signature += centroidItem->tierNodeItem.tier * centroidItem->centroidInfo.origNode.nodeId.name.name;
		centroidItem = centroidItem->nextItem;
	};

	return(signature);
};

bool Centroid::check_centroidScores() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, check_centroidScores\n");}
	RemoteCentroidItem_s *centroidItem;
	bool allValidScores;

	centroidItem = firstCentroidItem->nextItem;  // Skip first one as that is this node
	allValidScores = true;

	while (centroidItem != 0 && allValidScores == true) {

		if (centroidItem->centroidInfo.score == -1) {
			allValidScores = false;
		}

		centroidItem = centroidItem->nextItem;
	};

	return(allValidScores);
};
bool Centroid::amICentroid() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, amICentroid\n");}
	RemoteCentroidItem_s *centroidItem;
	float myLatestScore;
	bool meCentroid;

	myLatestScore = firstCentroidItem->centroidInfo.score;
	centroidItem = firstCentroidItem->nextItem;

	if (firstCentroidItem->centroidInfo.score != -1) {
		meCentroid = true;
	}
	else {
		meCentroid = false;
	};

//	cout << "\nNode: " << firstCentroidItem->centroidInfo.origNode.nodeId.name.name << " ";

	// Check if any node within domain radius has lowe score or equal score but higher node name than this node
	while (centroidItem != 0 && meCentroid == true) {
//		cout << "myScore: " << myLatestScore << " centroidScore: " << centroidItem->centroidInfo.score;

		if (centroidItem->centroidInfo.score <= myLatestScore && centroidItem->tierNodeItem.tier <= firstCentroidItem->centroidInfo.domainRadius) {  // Check if the node has higher score AND is within the domainRadius

			if (centroidItem->centroidInfo.centroidStatus == NOT_CENTROID || centroidItem->centroidInfo.centroidStatus == UNHOMED_CENTROID || centroidItem->centroidInfo.centroidStatus == I_CENTROID) {
//				cout << " centroidScore <= myScore";

				if (centroidItem->centroidInfo.score < myLatestScore) {
//					cout << "meCentroid = false";
					meCentroid = false;
				}
				else if (centroidItem->centroidInfo.score == myLatestScore && globalNameSpace->compare_names(centroidItem->centroidInfo.origNode.nodeId.name, firstCentroidItem->centroidInfo.origNode.nodeId.name) == true) {
//					cout << "meCentroid = false";
					meCentroid = false;
				}
			
			}

		}

		centroidItem = centroidItem->nextItem;
	}

	return(meCentroid);
};


bool Centroid::amIStableCentroid() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, amIStableCentroid\n");}
	CentroidItem_s *centroidItem;
	int i;
	bool stable;

	stable = true;

	for (i = 0; i < firstCentroidItem->centroidInfo.numberNodes && stable == true; i++) {
		centroidItem = this->get_centroidStatus(&firstCentroidItem->centroidInfo.domainNodes[i].domainNodeId);

		if (globalNameSpace->check_ifValid(centroidItem->currentCentroid.name) == true) {

			if (globalNameSpace->check_ifEqual(centroidItem->currentCentroid.name, firstCentroidItem->centroidInfo.currentCentroid.name) == false) {
				stable = false;
			}

		}

	}

	if (stable == true) {
		stableIterations++;
	}
	else {
		stableIterations = 0;
	};

	if (stable == true && stableIterations >= STABLE_CENTROID) {
		return(true);
	}
	else {
		return(false);
	};

};

RemoteCentroidItem_s *Centroid::set_centroid() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, set_centroid\n");}
	OverlapCentroid_s centroid, electedCentroid;
	int safePerimeter;
	bool safeCentroid;

	electedCentroid = this->check_listedElsewhere(&firstCentroidItem->centroidInfo.origNode.nodeId, 0);
	safePerimeter = firstCentroidItem->centroidInfo.domainRadius >> 1;  // The integer part of the half domain radius is the safe perimeter, i.e. all nodes within the perimeter belongs to this centroid

	if (electedCentroid.centroid != 0 && electedCentroid.centroid->tierNodeItem.tier > safePerimeter) {  // This node is listed in a domain node list of at least one other centroid which is outside the safe Perimeter
		centroid = this->check_listedElsewhere(&nodeRef->get_identity(), electedCentroid.centroid);
		safeCentroid = false;

		while (centroid.centroid != 0 && safeCentroid == false) {  // Compare the elected centroid with other centroids listing this node in its domain node list

			if (centroid.centroid->tierNodeItem.tier <= safePerimeter) {  // This centroid is within safe perimeter, selected this one
				electedCentroid = centroid;
				safeCentroid = true;
			}
			else if (centroid.centroid->tierNodeItem.tier <= firstCentroidItem->centroidInfo.domainRadius) {
				
				if (centroid.centroid->centroidInfo.score <= electedCentroid.centroid->centroidInfo.score) {

					if (centroid.centroid->centroidInfo.score < electedCentroid.centroid->centroidInfo.score) {
						electedCentroid = centroid;
					}
					else if (globalNameSpace->compare_names(centroid.centroid->centroidInfo.origNode.nodeId.name, electedCentroid.centroid->centroidInfo.origNode.nodeId.name) == true) {
						electedCentroid = centroid;
					};

				}

				centroid = this->check_listedElsewhere(&nodeRef->get_identity(), centroid.centroid);
			};

		};  // ENDWHILE centroid

	};

	// Make final check that selected centroid is within domain radius as this is not considered by check_listedElsewhere
	if (electedCentroid.centroid != 0) {

		if (electedCentroid.centroid->tierNodeItem.tier > firstCentroidItem->centroidInfo.domainRadius) {
			electedCentroid.centroid = 0;
		}

	}

	if (nodeRef->get_identity().name.name == 2746 && electedCentroid.centroid != 0) {
		cout << "\nTickpoint: " << SYSTEM->getTicks().tickPoint << " electedCentroid: " << electedCentroid.centroid->centroidInfo.origNode.nodeId.name.name << "\n";
	}
	else if (nodeRef->get_identity().name.name == 2746) {
		cout  << "\nTickpoint: " << SYSTEM->getTicks().tickPoint << " no elected centroid\n";
	};

	return(electedCentroid.centroid);
};

bool Centroid::set_domainNodes() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, set_domainNodes\n");}

	CenDomainNode_s newDomainNodes[MAX_DOMAINSIZE];
	RemoteCentroidItem_s *centroidItem; 
	OverlapCentroid_s overlapCentroid;
	int i, j, k, safePerimeter;
	bool difference, inList, myNode;

	newDomainNodes[0].domainNodeId = firstCentroidItem->centroidInfo.origNode.nodeId;
	newDomainNodes[0].safePerimeter = true;
	i = 1;  // The first one is this node
	centroidItem = firstCentroidItem->nextItem;
	safePerimeter = firstCentroidItem->centroidInfo.domainRadius >> 1;  // The integer part of the half domain radius is the safe perimeter, i.e. all nodes within the perimeter belongs to this centroid

//	cout << "\nNode: " << firstCentroidItem->centroidInfo.origNode.nodeId.name.name << " ";

	while (centroidItem != 0) {

		if (centroidItem->tierNodeItem.tier <= firstCentroidItem->centroidInfo.domainRadius) {  // The node is within the domainRadius

			if (centroidItem->tierNodeItem.tier <= safePerimeter) {
			
//				if (nodeRef->get_identity().name.name == 2942) {
//					cout << " mine, safePerimeter " << centroidItem->centroidInfo.origNode.nodeId.name.name << "\n";
//				}

				newDomainNodes[i].domainNodeId = centroidItem->centroidInfo.origNode.nodeId;
				newDomainNodes[i].safePerimeter = true;
//				cout << " safePerimeter " << centroidItem->centroidInfo.origNode.nodeId.name.name;
				i++;
			}
			else {   // It might belong to this centroid
				overlapCentroid = check_listedElsewhere(&(centroidItem->centroidInfo.origNode.nodeId), 0);

				if (overlapCentroid.centroid != 0) {
					myNode = true;

					while (overlapCentroid.centroid != 0 && myNode == true) { // Check for all listings of this node in domain node lists for other centroids
						// NB!!! Same domain radius is assumed for all centroids

						if (overlapCentroid.centroid->centroidInfo.domainNodes[overlapCentroid.overlapNodeIndex].safePerimeter == false) { // Only in case the node is NOT within the perimeter of the other centroid it might become part of this domain

							if (firstCentroidItem->centroidInfo.score >= overlapCentroid.centroid->centroidInfo.score) {

								if (firstCentroidItem->centroidInfo.score == overlapCentroid.centroid->centroidInfo.score && globalNameSpace->compare_names(firstCentroidItem->centroidInfo.origNode.nodeId.name, overlapCentroid.centroid->centroidInfo.origNode.nodeId.name) == false) {
									myNode = false;
								}
								else if (firstCentroidItem->centroidInfo.score > overlapCentroid.centroid->centroidInfo.score) {
									myNode = false;
								};

							};

						}
						else if (overlapCentroid.centroid->centroidInfo.domainNodes[overlapCentroid.overlapNodeIndex].safePerimeter == true && overlapCentroid.centroid->centroidInfo.centroidStatus != UNHOMED_CENTROID) {  // Takes care of the case when safePerimeter = true and centroidStatus differs from UNHOMED_CENTROID
							myNode = false;
						}
						else {
							myNode = false;
						};

						overlapCentroid = check_listedElsewhere(&(centroidItem->centroidInfo.origNode.nodeId), overlapCentroid.centroid);
					};  // ENDWHILE overlapCentroid

					if (myNode == true) {
					
//						if (nodeRef->get_identity().name.name == 2942) {
//							cout << " mine, overlapCentroid " << centroidItem->centroidInfo.origNode.nodeId.name.name << "\n";
//						}

						newDomainNodes[i].domainNodeId = centroidItem->centroidInfo.origNode.nodeId;
						newDomainNodes[i].safePerimeter = false;
						i++;
					}
				
				}
				else {
					newDomainNodes[i].domainNodeId = centroidItem->centroidInfo.origNode.nodeId;
					newDomainNodes[i].safePerimeter = false;

//					if (nodeRef->get_identity().name.name == 2942) {
//						cout << " mine, no overlapCentroid " << centroidItem->centroidInfo.origNode.nodeId.name.name << "\n";
//					}

					i++;
				};  // ENDIF overlapCentroid
				
			};  // ENDIF safePerimeter

		};  // ENDIF domainRadius

		// Check whether this node if outside the domain radius might be unhomed and likes to join this domain

		if (centroidItem->centroidInfo.centroidStatus == UNHOMED || centroidItem->centroidInfo.centroidStatus == UNHOMED_CENTROID) {
			
			if (globalNameSpace->check_ifEqual(centroidItem->centroidInfo.currentCentroid.name, firstCentroidItem->centroidInfo.origNode.nodeId.name) == true) {
				newDomainNodes[i].domainNodeId = centroidItem->centroidInfo.origNode.nodeId;
				newDomainNodes[i].safePerimeter = false;
//				cout << " UNHOMED " << centroidItem->centroidInfo.origNode.nodeId.name.name;
				i++;
			}

		}

		centroidItem = centroidItem->nextItem;
	};  // ENDWHILE centroidItem


	// Compare whether the new domain node list differs from the previous version

	if (i == firstCentroidItem->centroidInfo.numberNodes) { // At least it is still the same number of nodes
		difference = false;

		for (j = 0; j < i && difference == false; j++) {  // Compare for each node in the newly created domain list
			inList = false;

			for (k = 0; k < firstCentroidItem->centroidInfo.numberNodes && inList == false; k++) {

				if (globalNameSpace->check_ifEqual(newDomainNodes[j].domainNodeId.name, firstCentroidItem->centroidInfo.domainNodes[k].domainNodeId.name) == true) {
					inList = true;
				}

			};

			if (inList == false) { // No match found, there is a difference
				difference = true;
			};

		};

	}
	else {  // If not the same number of nodes, they must be different
		difference = true;
	};  // ENDIF numberNodes

	// Copy new domain list
	for (j = 0; j < i; j++) {
		firstCentroidItem->centroidInfo.domainNodes[j] = newDomainNodes[j];
	};			

	firstCentroidItem->centroidInfo.numberNodes = i;
//	cout << " numberNodes: " << i << " ";

	return(difference);
};

OverlapCentroid_s Centroid::check_listedElsewhere(Identity_s *nodeId, RemoteCentroidItem_s *lastReturned) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, check_listedElsewhere\n");}
	RemoteCentroidItem_s *centroidItem; 
	OverlapCentroid_s overlapCentroid;
	int i, numberNodes;
	bool inList;

	if (lastReturned == 0) {
		centroidItem = firstCentroidItem->nextItem;
	}
	else {
		centroidItem = lastReturned->nextItem;
	}

	inList = false;
	overlapCentroid.centroid = 0;
	overlapCentroid.overlapNodeIndex = -1;

	while (centroidItem != 0  && inList == false) {

		if (centroidItem->centroidInfo.centroidStatus == I_CENTROID || centroidItem->centroidInfo.centroidStatus == UNHOMED_CENTROID) {
			numberNodes = centroidItem->centroidInfo.numberNodes;

			for (i = 0; i < numberNodes; i++) {  // Check whether node can be found in domain node list, and whether it is within that other centroid's safe perimeter

				if (globalNameSpace->check_ifEqual(centroidItem->centroidInfo.domainNodes[i].domainNodeId.name, nodeId->name) == true) {
						inList = true;
						overlapCentroid.centroid = centroidItem;
						overlapCentroid.overlapNodeIndex = i;
				}

			};

		};

		centroidItem = centroidItem->nextItem;
	}  // ENDWHILE centroidItem, inList

	return(overlapCentroid);

};

RemoteCentroidItem_s *Centroid::findNearestCentroid() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, findNearestCentroid\n");}
	RemoteCentroidItem_s *centroidItem, *nearestCentroid, *candidateCentroid; 
//	OverlapCentroid_s centroid;

	nearestCentroid = 0;
	centroidItem = firstCentroidItem->nextItem;  // Skip first Centroid as it points to this node

	// Check whether any first tier nodes are listed among the domain node lists of Centroids being outside the domain radius; this is to ensure connectivity to that Centroid and its domain

	while (centroidItem != 0) {

		if (centroidItem->centroidInfo.centroidStatus == I_CENTROID) {
			candidateCentroid = centroidItem;

			if (nearestCentroid == 0) {
				nearestCentroid = candidateCentroid;
			}
			else {

				if (candidateCentroid->tierNodeItem.tier < nearestCentroid->tierNodeItem.tier) {
					nearestCentroid = candidateCentroid;
				}
				else if (candidateCentroid->tierNodeItem.tier == nearestCentroid->tierNodeItem.tier) {
					
					if (candidateCentroid->centroidInfo.score < nearestCentroid->centroidInfo.score) {
						nearestCentroid = candidateCentroid;
					}
					else if (candidateCentroid->centroidInfo.score == nearestCentroid->centroidInfo.score) {

						if (globalNameSpace->compare_names(candidateCentroid->centroidInfo.origNode.nodeId.name, nearestCentroid->centroidInfo.origNode.nodeId.name) == true) {
							nearestCentroid = candidateCentroid;
						}

					};

				};

			};

/*
		if (centroidItem->tierNodeItem.tier == 1) { // This node is in the first tier

			centroid = check_listedElsewhere(&(centroidItem->centroidInfo.origNode.nodeId), 0);

			while (centroid.centroid != 0) {

				if (nearestCentroid != 0 && centroid.centroid->tierNodeItem.tier < nearestCentroid->tierNodeItem.tier) {
					nearestCentroid = centroid.centroid;
				}
				else if (nearestCentroid != 0 && centroid.centroid->tierNodeItem.tier == nearestCentroid->tierNodeItem.tier) {

					if (globalNameSpace->compare_names(centroid.centroid->centroidInfo.origNode.nodeId.name, nearestCentroid->centroidInfo.origNode.nodeId.name) == true) {
						nearestCentroid = centroid.centroid;
					}
				}
				else if (nearestCentroid == 0) {
					nearestCentroid = centroid.centroid;
				};

				centroid = check_listedElsewhere(&(centroidItem->centroidInfo.origNode.nodeId), centroid.centroid);
			}; // ENDWHILE centroid

		}; // ENDIF firstTier
*/
		};  // ENDIF I_CENTROID

		centroidItem = centroidItem->nextItem;
	}; // ENDWHILE centroidItem

	return(nearestCentroid);

};

bool Centroid::compare_domainOverlap() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, compare_domainOverlap\n");}
	// Compare the relative overlap between the old and the new domain
	int oldInNew, oldNotInNew, newInNew;
	int i, j;
	bool nonOverlap, oldInNewMatch;

	oldInNew = oldNotInNew = 0;

	for (i = 0; i < oldDomain.oldDomainSize; i++) {
		oldInNewMatch = false;

		for (j = 0; j < currentCentroid->centroidInfo.numberNodes && oldInNewMatch == false; j++) {

			if (globalNameSpace->check_ifEqual(oldDomain.domainNodes[i].domainNodeId.name, currentCentroid->centroidInfo.domainNodes[j].domainNodeId.name) == true) {
				oldInNew++;
				oldInNewMatch = true;
			}

		};

		if (oldInNewMatch == false) { // There was no match
			oldNotInNew++;
		}

	};

	newInNew = currentCentroid->centroidInfo.numberNodes - oldInNew;

	cout << "\noldInNew: " << oldInNew << " oldNotInNew: " << oldNotInNew << " newInNew: " << newInNew << "\n";

	if ((oldInNew - oldNotInNew - newInNew)/currentCentroid->centroidInfo.numberNodes > MIN_DOMAINOVERLAP) {
		nonOverlap = false;
	}
	else {
		nonOverlap = true;
	};

	return(nonOverlap);
};

bool Centroid::compare_domainTopOverlap() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, compare_domainTopOverlap\n");}
	// Compare the relative overlap between the "existing" domain (the one controlled by the demoted Centroid, and stored in oldDomain) and the existing topology
	int domInTop;
	int i;
	bool overlap;
	TierNodeItem_s tierItem;
	RemoteCentroidItem_s *remCentroidItem;
	
	domInTop = 0;
	overlap = false;

	for (i = 0; i < oldDomain.oldDomainSize; i++) { // This assumes that the domain node list doesn't change after the centroid became demoted
		tierItem = sortedTopRef->find_tierNodeItem(&oldDomain.domainNodes[i].domainNodeId);

		if (tierItem.tier != -1 && tierItem.tier <= firstCentroidItem->centroidInfo.domainRadius) {  // This logic doesn't count potential UNHOMED nodes that were part of the domain but which is outside the domain radius
			domInTop++;
		}
		else if (tierItem.tier != -1) {
			remCentroidItem = find_remoteCentroidItem(&tierItem.remoteNodeTop->origNode.nodeId);

			if (remCentroidItem != 0) {

				if (globalNameSpace->check_ifEqual(remCentroidItem->centroidInfo.currentCentroid.name, nodeRef->get_identity().name) == true) {  // I.e. this is a node outside the domain radius and which is UNHOMED but was associated to this centroid
					domInTop++;
				}

			}

		};

	};

	if (firstCentroidItem->centroidInfo.numberNodes != 0) {
		
		if (domInTop/firstCentroidItem->centroidInfo.numberNodes > MIN_DOMAIN_IN_TOP_OVERLAP) {
			overlap = true;
		}
		else {
			overlap = false;
		};

	}

	return(overlap);
};

int Centroid::saveDomain(Identity_s *nodeId, Identity_s *superNodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, saveDomain\n");}
	CentroidItem_s *centroidItem;
	int i;

	centroidItem = this->get_centroidStatus(nodeId);

	if (centroidItem != 0) {

		for (i = 0; i < centroidItem->numberNodes; i++) {
			oldDomain.domainNodes[i] = centroidItem->domainNodes[i];
		}

		oldDomain.oldDomainSize = i;
		oldDomain.centroidNodeId = centroidItem->origNode.nodeId;
		oldDomain.superNodeId = *superNodeId;

		return(0);
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "saveDomain", "Invalid_nodeID", SYS_ERR_HARD);
		return(-1);
	};

};

Identity_s Centroid::get_savedDomainSuperNode() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_savedDomainSuperNode\n");}
	return(oldDomain.superNodeId);
};

Identity_s Centroid::get_savedDomainCentroidNode() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_savedDomainCentroidNode\n");}
	return(oldDomain.centroidNodeId);
};

int Centroid::get_domainNodeDiffs() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_domainNodeDiffs\n");}
	return(domainNodeDiffs);
};
void Centroid::reset_domainNodeDiffs() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, reset_domainNodeDiffs\n");}
	domainNodeDiffs = 0;
};
void Centroid::reset_savedDomain() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, reset_savedDomain\n");}

	oldDomain.oldDomainSize = 0;
	oldDomain.superNodeId = identity.reset_anotherIdentity();
	oldDomain.centroidNodeId = identity.reset_anotherIdentity();
};

bool Centroid::check_ifDomainNode(Identity_s *nodeId) { // Check if node is part of domain
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, check_ifDomainNode\n");}
	int i, numberDomainNodes;
	bool inDomain;
	RemoteCentroidItem_s *remCentroidItem;

	inDomain = false;
	numberDomainNodes = 0;
	remCentroidItem = this->find_remoteCentroidItem(&nodeRef->get_superNodePDUProvider(false));

	if (remCentroidItem != 0) {
		numberDomainNodes = remCentroidItem->centroidInfo.numberNodes;
	}
	else {  // If no centroid exists that also send SuperNode PDUs, there is no reason to assert domain borders
		inDomain = true;  
	};

	for (i = 0; i < numberDomainNodes && inDomain == false; i++) {

		if (globalNameSpace->check_ifEqual(remCentroidItem->centroidInfo.domainNodes[i].domainNodeId.name, nodeId->name) == true) {
			inDomain = true;
		}

	};

	return (inDomain);

};

int Centroid::update_nodeInfDomainLevel() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, update_nodeInfDomainLevel\n");}
	NodeTopologyItem_s *nodeTopItem;
	NeighborNodeItem_s *neighborInfo;
	DomainLevel domainLevel;
	Identity_s superNodeId;
	bool outOfDomain;
	int i, numberNeighbors;

	// Checks whether a node interface is a domain interface. Please note that a node interface is treated as a domain interface in case at least one other neighbor belongs to another domain

	superNodeId = nodeRef->get_superNodeId();
	nodeTopItem = nodeTopologyRef->getNext_nodeTopItem(false);

	while (nodeTopItem != 0) {
		numberNeighbors = nodeTopItem->currentNumberNeighbors;
		neighborInfo = nodeTopItem->firstNeighborItem;
		outOfDomain = false;

		for (i = 0; i < numberNeighbors && outOfDomain == false; i++) {

			if (check_ifDomainNode(&neighborInfo->neighbor.remoteNode.nodeId) == false) {
				outOfDomain = true;
			}

			neighborInfo = neighborInfo->nextItem;
		};

		domainLevel = nodeRef->get_myNodeInfo()->nodeTraits.domainLevel;

		if (SYS_eventTrace == true) {

			if (nodeTopItem->attachedExtLink != 0) {  // No reason to report unless an external link is attached
				Identity_s idArray[3];
				DomainLevel oldDomainLevel, newDomainLevel;
				oldDomainLevel = nodeTopItem->nodeInterface->get_interfaceDomainLevel();
				idArray[0] = nodeTopItem->nodeInterface->get_identity();
				idArray[1] = nodeTopItem->attachedExtLink->get_identity();
				idArray[2] = identity.reset_anotherIdentity();

				if (outOfDomain == true && domainLevelAlg->isHigher(oldDomainLevel, domainLevel) == false) {  // This interface has become a domain border
					newDomainLevel = domainLevelAlg->increaseDomainLevel(oldDomainLevel);
					SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_MEDIUM, "Node_Interface_has_become_domain_border", (int *) &newDomainLevel, 0, 0, idArray);
				}
				else if (outOfDomain == false && domainLevelAlg->isHigher(oldDomainLevel, domainLevel) == true) { // This interface is no longer a domain border
					newDomainLevel = domainLevelAlg->decreaseDomainLevel(oldDomainLevel);
					SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_MEDIUM, "Node_Interface_is_no_longer_a_domain_border", (int *) &newDomainLevel, 0, 0, idArray);
				};

			}

		}

		if (outOfDomain == true) {
			nodeTopologyRef->set_interfaceDomainLevel(nodeTopItem->nodeInterface, domainLevelAlg->increaseDomainLevel(domainLevel));

			if (globalNameSpace->check_ifValid(superNodeId.name) == true) {
				nodeTopItem->attachedExtLink->attach_superNode(&superNodeId, nodeTopItem->localExtLinkEndpoint);
			}

		}
		else {
			nodeTopologyRef->set_interfaceDomainLevel(nodeTopItem->nodeInterface, domainLevel);

			if (nodeTopItem->attachedExtLink != 0) {
				nodeTopItem->attachedExtLink->remove_superNode(nodeTopItem->localExtLinkEndpoint);
			}

		};

		nodeTopItem = nodeTopologyRef->getNext_nodeTopItem(false);
	};

	return(0);
};

void Centroid::reset_nodeInfDomainLevel() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, reset_nodeInfDomainLevel\n");}
	NodeTopologyItem_s *nodeTopItem;
	DomainLevel domainLevel;

	nodeTopItem = nodeTopologyRef->getNext_nodeTopItem(false);
	domainLevel = nodeRef->get_myNodeInfo()->nodeTraits.domainLevel;

	while (nodeTopItem != 0) {
		nodeTopItem->nodeInterface->set_interfaceDomainLevel(domainLevel);
		nodeTopItem = nodeTopologyRef->getNext_nodeTopItem(false);
	};

	if (SYS_eventTrace == true) { SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_MEDIUM, "Domain_borders_reset", (int *) &domainLevel, 0, 0, 0);}
};

int Centroid::get_refreshCount() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_refreshCount\n");}
	return(firstCentroidItem->refreshCount);
};

int Centroid::get_reissueCount() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_reissueCount\n");}
	return(firstCentroidItem->reissueCount);
};

int Centroid::get_centroidVersion() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_centroidVersion\n");}
	return(firstCentroidItem->centroidInfo.version);
};

int Centroid::get_currentNumberCentroids() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_currentNumberCentroids\n");}
	return(currentNumberCentroids);
};

int Centroid::get_currentNumberDomainNodes() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_currentNumberDomainNodes\n");}

	if (firstCentroidItem->centroidInfo.centroidStatus == UNHOMED_CENTROID) {  // Return the domian node set of this node
		return(firstCentroidItem->centroidInfo.numberNodes);
	}
	else if (currentCentroid != 0) {
		return(currentCentroid->centroidInfo.numberNodes);
	}
	else {
		return(0);
	};

};
Identity_s *Centroid::get_currentCentroid() {
if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, get_currentCentroid\n");}
Identity_s nodeId;

	if (currentCentroid != 0) {
		return(&currentCentroid->centroidInfo.origNode.nodeId);
	}
	else {
		nodeId = identity.reset_anotherIdentity();
		return(&nodeId);
	};

};
void Centroid::CALLBACK_tickZero(void *parameters, int secret) {
	if (SYS_threadTrace== true) { SYSTEM->threadTrace(&identity.get_identity(), &this->nodeRef->get_identity());}
	CALLBACK_update_centroids();

	ticksDiff.tickPoint += SYSTEM->subTicks(SYSTEM->getTicks(), lastTicksRead).tickPoint;
	lastTicksRead = SYSTEM->getTicks();

	if (ticksDiff.tickPoint > SYSTEM->msToTick(GP_CENTROID_INTERVAL).tickPoint) {
		firstCentroidItem->refreshCount++;
		ticksDiff.tickPoint = 0;
	};

	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(centroidTicks), CB_CENTROID, 0);
};

void Centroid::CALLBACK_update_centroids() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("Centroid, CALLBACK_update_centroids\n");}
	RemoteCentroidItem_s *centroidItem, *oldCentroidItem, *selectedCentroid, *nearestCentroid;
	CentroidStatus currentStatus, newStatus;
	float oldScore, newScore;
	int newSignature, i;
	bool meCentroid, domainNodeDiff, upgradeVersion;
	Identity_s idArray[MAX_DOMAINSIZE+1];  // Used for reporting/debugging

	centroidItem = getNext_remoteCentroidItem(false);  // This first item is always this node, thus should not be checked.
	centroidItem = getNext_remoteCentroidItem(false);

	while (centroidItem != 0) {

		if (centroidItem->timeToLive.tickPoint <= SYSTEM->getTicks().tickPoint) { // The item shall be removed
			oldCentroidItem = centroidItem;

			if (centroidItem == firstCentroidItem) {   // In current implementation, this can never happen as first node is this node
				firstCentroidItem = centroidItem->nextItem;
				centroidItem->nextItem->previousItem = 0;
			}
			else if (centroidItem->nextItem == 0) {  // Last item
				centroidItem->previousItem->nextItem = 0;
			}
			else {
				centroidItem->previousItem->nextItem = centroidItem->nextItem;
				centroidItem->nextItem->previousItem = centroidItem->previousItem;
			};

			if (oldCentroidItem == currentCentroid) { // Reset currentCentroid
				currentCentroid = 0;
			};

			currentNumberCentroids--;
		}
		else {
			oldCentroidItem = 0;
		};

		centroidItem = getNext_remoteCentroidItem(false);

		if (oldCentroidItem != 0) {
			delete oldCentroidItem;
		}

	};  // ENDWHILE topologyItem

	if (check_topologyConsistency() == 0) {  // All is well
		newScore = calculate_centroidScore();
		if (SYS_eventTrace == true) { SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_LOW, "Centroid_score", 0, &(firstCentroidItem->centroidInfo.score), 0, 0);}

//		newSignature = calculate_centroidSignature();
//		currentStatus = firstCentroidItem->centroidInfo.centroidStatus;
		currentStatus = newStatus = firstCentroidItem->centroidInfo.centroidStatus;
		domainNodeDiff = false;
		upgradeVersion = false;
		selectedCentroid = 0;
		oldScore = firstCentroidItem->centroidInfo.score;

		if (this->check_centroidScores() == true) { // All nodes in Centroid DB have calculated a valid score, calculate new Centroid status
//		if (newSignature != signature && signature != 0) {  // Revert to NOT_CENTROID and make a new Centroid selection
//			if (SYS_eventTrace == true) { SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_LOW, "New_signature", 0, 0, 0, 0);}
//			newStatus = NOT_CENTROID;
				
//			if (globalNameSpace->check_ifEqual(nodeRef->get_superNodePDUProvider(false).name, nodeRef->get_identity().name) == false) {  // The "old"/current domain will remain in operation until another centroid starts sending SuperNode PDUs
//				firstCentroidItem->centroidInfo.numberNodes = 0;
//			}

//		}
//		else {
//			firstCentroidItem->centroidInfo.score = calculate_centroidScore();
//			if (SYS_eventTrace == true) { SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_LOW, "Centroid_score", 0, &(firstCentroidItem->centroidInfo.score), 0, 0);}

			meCentroid = amICentroid();

			if (meCentroid == false) {
				selectedCentroid = set_centroid();

				if (globalNameSpace->check_ifEqual(nodeRef->get_superNodePDUProvider(false).name, nodeRef->get_identity().name) == false) {  // The old domain will remain in operation until another centroid starts sending SuperNode PDUs
					firstCentroidItem->centroidInfo.numberNodes = 0;
				}

			}
			else {

				if (SYSTEM->getTicks().tickPoint == 9807 && nodeRef->get_identity().name.name == 1276) {
					cout << "Node 27!";
				}

				domainNodeDiff = set_domainNodes();
			};

			// First two IFs are for this node being a centroid
			if (meCentroid == true && firstCentroidItem->centroidInfo.numberNodes >= MIN_DOMAINSIZE) {
				// This node is a centroid and the domain is being big enough to create a domain on its own
				newStatus = I_CENTROID;
				selectedCentroid = firstCentroidItem;
			}
			else if (meCentroid == true && firstCentroidItem->centroidInfo.numberNodes < MIN_DOMAINSIZE) {
				// This node is a centroid but the domain is NOT big enough to create a domain on its own
				newStatus = UNHOMED_CENTROID;
				nearestCentroid = findNearestCentroid();
				selectedCentroid = nearestCentroid;
			}
			else if (meCentroid == false && selectedCentroid != 0) {
				// This node is NOT a centroid, and have selected a node to be centroid
				if (selectedCentroid->centroidInfo.centroidStatus == I_CENTROID) {
					newStatus = NOT_ELIGIBLE;
//					firstCentroidItem->centroidInfo.numberNodes = 0;  DONE above!!!
				}
				else if (selectedCentroid->centroidInfo.centroidStatus == UNHOMED_CENTROID) {
					newStatus = UNHOMED;
					nearestCentroid = findNearestCentroid();
//					firstCentroidItem->centroidInfo.numberNodes = 0;  DONE above!!!
					selectedCentroid = nearestCentroid;
				}
			}
			else if (meCentroid == false && selectedCentroid == 0) {
				// This node is NOT a centroid, and has not found anyone that is a centroid
				newStatus = NOT_CENTROID;
//				firstCentroidItem->centroidInfo.numberNodes = 0;  DONE above!!
			};

		};

//		signature = newSignature;

		if (newStatus != currentStatus) {
			upgradeVersion = true;
//			firstCentroidItem->centroidInfo.version++;
//			firstCentroidItem->refreshCount = 0;
			firstCentroidItem->centroidInfo.centroidStatus = newStatus;

			if (SYS_eventTrace == true) {
			
				if (newStatus == I_CENTROID) {
					SYSTEM->eventTrace(&identity.get_identity(), &this->nodeRef->get_identity(), SYS_LL_HIGH, "Promoted_Centroid", (int *) &firstCentroidItem->centroidInfo.numberNodes, &firstCentroidItem->centroidInfo.score, &domainNodeDiff, 0);
				}
				else if (currentStatus == I_CENTROID) {
					SYSTEM->eventTrace(&identity.get_identity(), &this->nodeRef->get_identity(), SYS_LL_HIGH, "Demoted_Centroid", (int *) &firstCentroidItem->centroidInfo.numberNodes, &firstCentroidItem->centroidInfo.score, 0, 0);
				};
			}

		}

//		else if (oldScore != firstCentroidItem->centroidInfo.score) {
		if (oldScore != newScore) {
			firstCentroidItem->centroidInfo.score = newScore;
			upgradeVersion = true;
//			firstCentroidItem->centroidInfo.version++;
//			firstCentroidItem->refreshCount = 0;
		}

//		else if (domainNodeDiff == true) {
		if (domainNodeDiff == true) {
			upgradeVersion = true;
			domainNodeDiffs++;
//			firstCentroidItem->centroidInfo.version++;
//			firstCentroidItem->refreshCount = 0;

			if (SYS_eventTrace == true) {

				for (i = 0; i < firstCentroidItem->centroidInfo.numberNodes; i++) {
					idArray[i] = firstCentroidItem->centroidInfo.domainNodes[i].domainNodeId;
				}

				idArray[i] = identity.reset_anotherIdentity();
				SYSTEM->eventTrace(&identity.get_identity(), &this->nodeRef->get_identity(), SYS_LL_MEDIUM, "Domain_node_set_changed", (int *) &firstCentroidItem->centroidInfo.numberNodes, 0, 0, idArray);
			}

		}
//		else {
//			firstCentroidItem->refreshCount++;  // Is done as part of the tickZero routine!!!
//		};

		if (currentCentroid != selectedCentroid) {
			upgradeVersion = true;

			if (selectedCentroid != 0) {
				firstCentroidItem->centroidInfo.currentCentroid = selectedCentroid->centroidInfo.origNode.nodeId;

//				if (selectedCentroid != firstCentroidItem) {
//					firstCentroidItem->centroidInfo.numberNodes = 0;
//				}

			}
			else {
				firstCentroidItem->centroidInfo.currentCentroid = identity.reset_anotherIdentity();
//				firstCentroidItem->centroidInfo.numberNodes = 0;
			};

			oldCentroid = currentCentroid;
			currentCentroid = selectedCentroid;

			if (SYS_eventTrace == true && selectedCentroid != firstCentroidItem) {  // No need to report unless the selected centroid is another node than this

				if (selectedCentroid != 0) {
					idArray[0] = selectedCentroid->centroidInfo.origNode.nodeId;
				}
				else {
					idArray[0] = identity.reset_anotherIdentity();
				};

				idArray[1] = identity.reset_anotherIdentity();
				SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_HIGH, "Changed_selected_Centroid", 0, 0, 0, idArray);
			}

		};

		if (upgradeVersion == true) {
			firstCentroidItem->centroidInfo.version++;
			firstCentroidItem->refreshCount = 0;
		}

		if (firstCentroidItem->centroidInfo.centroidStatus == I_CENTROID && this->amIStableCentroid() == true && stableCentroid == false) {
			stableCentroid = true;
			if (SYS_eventTrace == true) { SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_MEDIUM, "Stable_centroid", 0, 0, 0, 0);}
//			this->nodeRef->printMe(OBJ_ALL);
		}
		else if (firstCentroidItem->centroidInfo.centroidStatus != I_CENTROID && stableCentroid == true) {
			stableCentroid = false;
			if (SYS_eventTrace == true) { SYSTEM->eventTrace(&identity.get_identity(), &nodeRef->get_identity(), SYS_LL_MEDIUM, "Lost_position_as_stable_centroid", 0, 0, 0, 0);}
//			this->nodeRef->printMe(OBJ_ALL);
		};

	}; //ENDIF check_topologyConsistency

};

void Centroid::CALLBACK_checkTimeToLive() {  // This function is not in use
};

ostream &operator<<(ostream &stream, Centroid *ce) {
	RemoteCentroidItem_s *centroidItem;
	Identity *idp;
	Identity_s id;
	int i, numberDomainNodes, nodesInRow;
	string extName;

	idp = &ce->identity;
	stream << "Centroid_Status:\n" << idp << "\n";

	if (ce->firstCentroidItem->centroidInfo.centroidStatus == I_CENTROID) {
		stream << "This node is a centroid, stable centroid: " << ce->stableCentroid << "\n";
		stream << "Current number of nodes in domain: " << ce->currentCentroid->centroidInfo.numberNodes << "\n";
		stream << "Node list:\n";
		nodesInRow = 0;

		for (i = 0; i < ce->currentCentroid->centroidInfo.numberNodes; i++) {
			id = ce->currentCentroid->centroidInfo.domainNodes[i].domainNodeId;
			extName = SYSTEM->find_nodeExtName(&id);
			stream << id.type << " / " << id.nickName << " / " << id.name.name << " , ";
			nodesInRow++;

			if (nodesInRow == 5) {  // Wrap around
				stream << "\n";
				nodesInRow = 0;
			}

		};

		if (nodesInRow != 0) {
			stream << "\n";
			nodesInRow = 0;
		}

	}
	else {
		stream << "This node is NOT a centroid, status = " << ce->firstCentroidItem->centroidInfo.centroidStatus << "\n";;
		id = ce->firstCentroidItem->centroidInfo.currentCentroid;

		if (ce->nodeRef->get_myNodeInfo()->coreNode == true) {
			extName = SYSTEM->find_nodeExtName(&id);
			stream << "This node's view of who is current centroid: " << extName << " / " << id.name.name << "\n";
		}
		else {
			stream << "This node's view of who is current centroid: " << id.type << " / " << id.nickName << " / " << id.name.name << "\n";
		};

	};

	stream << "Current number nodes in centroid DB: " << ce->currentNumberCentroids << " Signature: " << ce->signature <<" Centroid score: " << ce->firstCentroidItem->centroidInfo.score << " Version: " << ce->firstCentroidItem->centroidInfo.version << "\n";

	if (SYSTEM->get_logLevel() == SYS_LL_ALL) {
		centroidItem = ce->firstCentroidItem;
		stream << "\nCentroid\tStatus\tTier\tScore\tCurrentCentroid\tDomainNodes\n";

		while (centroidItem != 0) {
			id = centroidItem->centroidInfo.origNode.nodeId;
			
			if (ce->nodeRef->get_myNodeInfo()->coreNode == true) {
				extName = SYSTEM->find_nodeExtName(&id);
				stream << extName << " / " << id.name.name << "\t" << centroidItem->centroidInfo.centroidStatus << "\t" << centroidItem->tierNodeItem.tier << "\t" << centroidItem->centroidInfo.score;
				extName = SYSTEM->find_nodeExtName(&centroidItem->centroidInfo.currentCentroid);
				stream << "\t" << extName << " / " << centroidItem->centroidInfo.currentCentroid.name.name;
			}
			else {
				stream << id.nickName << " / " << id.name.name << "\t" << centroidItem->centroidInfo.centroidStatus << "\t" << centroidItem->tierNodeItem.tier << "\t" << centroidItem->centroidInfo.score;
				stream << "\t" << centroidItem->centroidInfo.currentCentroid.nickName << "/" << centroidItem->centroidInfo.currentCentroid.name.name;
			};

			if (centroidItem->centroidInfo.centroidStatus == I_CENTROID || centroidItem->centroidInfo.centroidStatus == UNHOMED_CENTROID) {
				numberDomainNodes = centroidItem->centroidInfo.numberNodes;
				stream << "\t";

				for (i = 0; i < numberDomainNodes; i++) {
					id = centroidItem->centroidInfo.domainNodes[i].domainNodeId;

					if (ce->nodeRef->get_myNodeInfo()->coreNode == true) {
						extName = SYSTEM->find_nodeExtName(&id);
						stream << " " << extName << " / " << id.name.name << " ";
					}
					else {
						stream << " " << id.type << " / " << id.nickName << " / " << id.name.name << " ";
					};

				}
			
			}

			stream << "\n";
			centroidItem = centroidItem->nextItem;
		}

	}

	stream << "End_Centroid_Status\n";

	return stream;
}


// CLASS LINKABSTRACTION FUNCTIONS

void LinkAbstraction::LinkAbstraction_init(Identity_s *id, Node *nodeRef, NodeTopology *nodeExtTopRef) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, init\n");}

	currentNumberLinkAbstractions = 0;
	firstLinkAbstraction = nextLinkAbstraction = 0;
	linkAbstTicks = SYSTEM->msToTick(LINKABSTRACTION_INTERVAL);
	thisNode = nodeRef;
	nodeExtTopologyRef = nodeExtTopRef;
	identity.Identity_init(id);
	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(linkAbstTicks), CB_LINKABST, 0);
};

void LinkAbstraction::LinkAbstraction_delete() {  // Too simple, e.g. links must also be deleted!!!
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, delete\n");}
	LinkAbstInfo_s *linkAbst; 

	linkAbst = firstLinkAbstraction;

	while (linkAbst != 0) {
		linkAbst = this->remove_linkAbstraction(&linkAbst->horLinkRef->get_identity());
	};

	if (callbackRef != -1) {
		SYSTEM->delete_ticksQueueEvent(callbackRef);
		callbackRef = -1;
		cout << "LinkAbsts Callback\n";
	}

};

LinkAbstInfo_s *LinkAbstraction::add_linkAbstraction(Link *horLink, bool linkBuilder, Identity_s *origNodeId, string nameTag) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, add_linkAbstraction\n");}

	LinkAbstInfo_s *linkAbst, *newLinkAbst, *lastLinkAbst;
	NodeInterface *newNodeInf;
	Link *horizontalLink, *verticalLink;
	LinkEndpoint *horLinkEndpoint, *verLinkEndpoint;
	Identity_s nodeInfId, horLinkId, verLinkId, horLinkEndpointId, verLinkEndpointId;
	NodeInterfaceTraits_s nodeInfTraits;
	LinkTraits_s horLinkTraits, verLinkTraits;
	LinkEndpointTraits_s horLinkEndpointTraits, verLinkEndpointTraits;

	// Check first whether linkabstraction already exists
	if (this->checkIfLinkAbst_exists(horLink) != 0) {
		SYSTEM->runtimerror(&identity.get_identity(), "add_linkAbstraction", "Linkabstraction_info_already_exists", SYS_ERR_HARD);
		return(0);
	}
	
	try {
		newLinkAbst = new LinkAbstInfo_s;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&identity.get_identity(), "add_linkAbstraction","allocation_failure", SYS_ERR_HARD);
		return(0);
	}

	newLinkAbst->initialized = false;

	// Find last item in list
	linkAbst = firstLinkAbstraction;
	lastLinkAbst = 0;

	while (linkAbst != 0) {
		lastLinkAbst = linkAbst;
		linkAbst = linkAbst->nextItem;
	};

	if (lastLinkAbst != 0) {
		lastLinkAbst->nextItem = newLinkAbst;
		newLinkAbst->previousItem = lastLinkAbst;
		newLinkAbst->nextItem = 0;
	}
	else {
		firstLinkAbstraction = newLinkAbst;
		newLinkAbst->previousItem = newLinkAbst->nextItem = 0;
	};

	// Create node interface, and the horizontal link (unless already created) and vertical links
	try {
		newNodeInf = new NodeInterface;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&identity.get_identity(), "CALLBACK_update_linkAbstraction","allocation_failure", SYS_ERR_HARD);
	}

	nodeInfId.type = "NODEINTERFACE";
	nodeInfId.nickName = "-";
	nodeInfTraits.genInfTraits.completionTime = nodeInfTraits.genInfTraits.mtbf = 0;
	nodeInfTraits.attPointExtTraits.flowdir = nodeInfTraits.attPointIntTraits.flowdir = nodeInfTraits.attPointVerTraits.flowdir = TRANCEIVER;
	nodeInfTraits.attPointExtTraits.beacon = nodeInfTraits.attPointIntTraits.beacon = nodeInfTraits.attPointVerTraits.beacon = false;
	nodeInfTraits.infExtTraits.queueRxLength = nodeInfTraits.infExtTraits.queueTxLength = MAX_PDUQUEUE_LENGTH;
	nodeInfTraits.infIntTraits.queueRxLength = nodeInfTraits.infIntTraits.queueTxLength = 0;
	nodeInfTraits.infVerTraits.queueRxLength = nodeInfTraits.infVerTraits.queueTxLength = 0;

	newNodeInf->NodeInterface_init(&nodeInfId, thisNode->get_myNodeInfo()->nodeTraits.domainLevel, thisNode, nodeInfTraits, 0);
	thisNode->install_nodeInf(newNodeInf);

	try {
		verticalLink = new Link;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&identity.get_identity(), "CALLBACK_update_linkAbstraction","allocation_failure", SYS_ERR_HARD);
	}

	verLinkId.type = "LINK";
	verLinkId.nickName = "-";
	verLinkTraits.genTransmission.completionTime = 0;
	verLinkTraits.genTransmission.mtbf = 0;
	verLinkTraits.length = 0;
	verLinkTraits.maxLinkEndpoints = MAX_LINKENDPOINTS_VL;
	verLinkTraits.transmission.bandwidth = verLinkTraits.transmission.ber = 0;  // Infinite bandwidth
	verticalLink->Link_init(&verLinkId, false, verLinkTraits, 0, 0);

	try {
		verLinkEndpoint = new LinkEndpoint;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&identity.get_identity(), "CALLBACK_update_linkAbstraction","allocation_failure", SYS_ERR_HARD);
	}

	verLinkEndpointId.type = "LINKENDPOINT";
	verLinkEndpointId.nickName = "-";
	verLinkEndpointTraits.genTraits.completionTime = 0;
	verLinkEndpointTraits.genTraits.mtbf = 0;
	verLinkEndpointTraits.attPointTraits.flowdir = TRANCEIVER;
	verLinkEndpointTraits.attPointTraits.beacon = false;
	verLinkEndpoint->LinkEndpoint_init(&verLinkEndpointId, verLinkEndpointTraits, 0);

	verticalLink->add_linkEndpoint(verLinkEndpoint);
	thisNode->attach_verDownLink(newNodeInf, verticalLink, verLinkEndpoint);

	if (horLink == 0) {
		// Create horizontal link								
		try {
			horizontalLink = new Link;
		} catch (bad_alloc xa) {
			SYSTEM->runtimerror(&identity.get_identity(), "CALLBACK_update_linkAbstraction","allocation_failure", SYS_ERR_HARD);
		}

		horLinkId.type = "LINK";
		horLinkId.nickName = "LA_" + nameTag;
		// NB! link and endpoint traits need to be calculated!!!
		horLinkTraits.genTransmission.completionTime = 0;
		horLinkTraits.genTransmission.mtbf = 0;
		horLinkTraits.length = LINK_DEFAULTLENGTH;
		horLinkTraits.maxLinkEndpoints = MAX_LINKENDPOINTS;
		horLinkTraits.transmission.bandwidth = horLinkTraits.transmission.ber = 0;  // Infinite bandwidth
		horizontalLink->Link_init(&horLinkId, false, horLinkTraits, LINK_TIMETOLIVE, &identity.get_identity());
		SYSTEM->report_entityCreation(&thisNode->get_identity(), &horizontalLink->get_identity(), horizontalLink);
	}
	else {
		horizontalLink = horLink;

		if (horLink->get_identity().name.name == 11325) {
			cout << "\nLA_P received by node: " << thisNode->get_identity().nickName << " at tickpoint: " << SYSTEM->getTicks().tickPoint << "\n";
		}

	};

	// Create and add link endpoint
	try {
		horLinkEndpoint = new LinkEndpoint;
	} catch (bad_alloc xa) {
		SYSTEM->runtimerror(&identity.get_identity(), "CALLBACK_update_linkAbstraction","allocation_failure", SYS_ERR_HARD);
	}

	// NB!!! Endpoint traits need proper calculation
	horLinkEndpointId.type = "LINKENDPOINT";
	horLinkEndpointId.nickName = "-";
	horLinkEndpointTraits.genTraits.completionTime = 0;
	horLinkEndpointTraits.genTraits.mtbf = 0;
	horLinkEndpointTraits.attPointTraits.flowdir = TRANCEIVER;
	horLinkEndpointTraits.attPointTraits.beacon = false;
	horLinkEndpoint->LinkEndpoint_init(&horLinkEndpointId, horLinkEndpointTraits, 0);
	horizontalLink->add_linkEndpoint(horLinkEndpoint);
	thisNode->attach_extLink(newNodeInf, horizontalLink, horLinkEndpoint);

	newLinkAbst->nodeInfRef = newNodeInf;
	newLinkAbst->origNodeId = *origNodeId;
	newLinkAbst->horLinkRef = horizontalLink;
	newLinkAbst->localHorLinkEndpoint = horLinkEndpoint;
	newLinkAbst->verLinkRef = verticalLink;
	newLinkAbst->localVerLinkEndpoint = verLinkEndpoint;
	newLinkAbst->linkBuilder = linkBuilder;
	newLinkAbst->numberLinks = 0;
	newLinkAbst->firstLinkAbstMsg = 0;


	currentNumberLinkAbstractions++;

	if (currentNumberLinkAbstractions == 1) { // First abstraction added
		nextLinkAbstraction = firstLinkAbstraction;
	}

	newLinkAbst->initialized = true;

	return(newLinkAbst);
};

LinkAbstInfo_s *LinkAbstraction::remove_linkAbstraction(Identity_s *linkId) { // NB!!! Will remove the link abstraction no matter number of underlying links it represents, will return pointer to next link abstraction
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, remove_linkAbstraction\n");}
	LinkAbstInfo_s *linkAbst, *nextLinkAbst;
	LinkAbstMsg_s *linkAbstMsg, *oldLinkAbstMsg;
	AttachedLink_s intLink;

	cout << "\nRemove linkAbstraction: " << linkId->nickName << "/" << linkId->name.name << " by node: " << thisNode->get_identity().nickName << " at tickpoint: " << SYSTEM->getTicks().tickPoint << "\n";

	linkAbst = this->find_linkAbstInfo(linkId, 0, 0);

	if (linkAbst != 0) {
		nextLinkAbst = linkAbst->nextItem;

		if (linkAbst == nextLinkAbstraction) {
			nextLinkAbstraction = nextLinkAbstraction->nextItem;
		}

		if (linkAbst == firstLinkAbstraction) {
			firstLinkAbstraction = firstLinkAbstraction->nextItem;

			if (firstLinkAbstraction != 0) {
				firstLinkAbstraction->previousItem = 0;
			}

		}
		else if (linkAbst->nextItem == 0) {  // Last item
			linkAbst->previousItem->nextItem = 0;
		}
		else {
			linkAbst->previousItem->nextItem = linkAbst->nextItem;
			linkAbst->nextItem->previousItem = linkAbst->previousItem;
		};

		currentNumberLinkAbstractions--;

		if (currentNumberLinkAbstractions == 0) { // Noone left
			firstLinkAbstraction = nextLinkAbstraction = 0;
		}

		// Detach the node from all interfaces, delete the node interface together with the external horizontal and vertical links (the two latter only if there are no nodes attached)
		thisNode->detach_extLink(linkAbst->nodeInfRef, linkAbst->horLinkRef);
		intLink = linkAbst->nodeInfRef->isIntLinkAttached();

		if (intLink.link != 0) {
			thisNode->detach_intLink(linkAbst->nodeInfRef, 0, intLink.link);
		}

		thisNode->detach_verDownLink(linkAbst->nodeInfRef, linkAbst->verLinkRef);
		thisNode->uninstall_nodeInf(linkAbst->nodeInfRef);
		linkAbst->horLinkRef->remove_linkEndpoint(linkAbst->localHorLinkEndpoint);
		linkAbst->localHorLinkEndpoint->LinkEndpoint_delete();
		delete linkAbst->localHorLinkEndpoint;

		if (linkAbst->horLinkRef->isAnyNodeAttached() == false) {
			SYSTEM->report_entityDeletion(&thisNode->get_identity(), &linkAbst->horLinkRef->get_identity(), 0, linkAbst->horLinkRef->get_myLinkInfo());
			linkAbst->horLinkRef->Link_delete();
			delete linkAbst->horLinkRef;
		}

		if (linkAbst->verLinkRef->isAnyNodeAttached() == false) {
			linkAbst->verLinkRef->Link_delete();
			delete linkAbst->verLinkRef;
		};

		linkAbst->nodeInfRef->NodeInterface_delete();
		delete linkAbst->nodeInfRef;

		linkAbstMsg = linkAbst->firstLinkAbstMsg;

		while (linkAbstMsg != 0) {
			oldLinkAbstMsg = linkAbstMsg;
			linkAbstMsg = linkAbstMsg->nextItem;
			delete oldLinkAbstMsg;
		}

		delete linkAbst;
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "remove_linkAbstraction", "Linkabstraction_info_doesn't_exist", SYS_ERR_HARD);
		return(0);
	};

	return(nextLinkAbst);
};

LinkAbstMsg_s *LinkAbstraction::add_underlyingLink(Link *horLink, Identity_s *linkId, NodeInfo_s *sourceNode) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, add_underlyingLink\n");}

	LinkAbstInfo_s *linkAbst;
	LinkAbstMsg_s *linkAbstMsg, *newLinkAbstMsg;

	linkAbst = this->find_linkAbstInfo(&horLink->get_identity(), 0, 0);

	if (linkAbst != 0) {
		// Check if underlying link has already been listed
		if (this->find_underlyingLink(linkAbst, linkId) == 0) {

			try {
				newLinkAbstMsg = new LinkAbstMsg_s;
			} catch (bad_alloc xa) {
				SYSTEM->runtimerror(&identity.get_identity(), "add_underlyingLink","allocation_failure", SYS_ERR_HARD);
				return(0);
			}

			linkAbstMsg = linkAbst->firstLinkAbstMsg;

			if (linkAbstMsg != 0) {

				while (linkAbstMsg->nextItem != 0) {
					linkAbstMsg = linkAbstMsg->nextItem;
				}

				linkAbstMsg->nextItem = newLinkAbstMsg;
				newLinkAbstMsg->prevItem = linkAbstMsg;
				newLinkAbstMsg->nextItem = 0;
				linkAbstMsg = newLinkAbstMsg;
			}
			else {
				linkAbstMsg = linkAbst->firstLinkAbstMsg = newLinkAbstMsg;
				linkAbstMsg->prevItem = linkAbstMsg->nextItem = 0;
			};

			linkAbst->numberLinks++;

			linkAbstMsg->currentVersion = 0;
			linkAbstMsg->reissueCount = linkAbstMsg->currentReissueCount = 0;
			linkAbstMsg->lastTicksRead = SYSTEM->getTicks();
			linkAbstMsg->ticksDiff.tickPoint = 0;
			linkAbstMsg->timeToLive.tickPoint = 0;
			linkAbstMsg->linkAbstractionBody.linkId = *linkId;
			linkAbstMsg->linkAbstractionBody.domainLevel = thisNode->get_myNodeInfo()->nodeTraits.domainLevel;
			linkAbstMsg->linkAbstractionBody.linkAbstraction = horLink;
			linkAbstMsg->linkAbstractionBody.numberPeers = 0;
			linkAbstMsg->linkAbstractionBody.sourceNode = *sourceNode;
			linkAbstMsg->linkAbstractionBody.version = 1;  // So that protocol can detect a diff
			linkAbstMsg->linkAbstractionBody.reissue = false;
			linkAbstMsg->linkAbstRefreshBody.sourceNode = *sourceNode;
			linkAbstMsg->linkAbstRefreshBody.linkAbstraction = horLink;
			linkAbstMsg->linkAbstRefreshBody.linkId = *linkId;
			linkAbstMsg->linkAbstRefreshBody.refreshCount = 0;
			linkAbstMsg->linkAbstRefreshBody.version = 1;

			return(linkAbstMsg);  // Returns the index to where the new underlying link is stored
		}
		else {
			SYSTEM->runtimerror(&identity.get_identity(), "add_underlyingLink", "Underlying_link_already_listed", SYS_ERR_HARD);
			return(0);
		};

	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "add_underlyingLink", "no_matching_linkabstraction", SYS_ERR_HARD);
		return(0);
	};

};

LinkAbstMsg_s *LinkAbstraction::remove_underlyingLink(Link *horLink, Identity_s *linkId) {  // Returns pointer to next available linkAbst Msg.
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, remove_underlyingLink\n");}

	LinkAbstInfo_s *linkAbst;
	LinkAbstMsg_s *linkAbstMsg, *nextLinkAbstMsg;

	linkAbst = this->find_linkAbstInfo(&horLink->get_identity(), linkId, 0);

	if (linkAbst != 0) {
		linkAbstMsg = this->find_underlyingLink(linkAbst, linkId);

		if (linkAbstMsg != 0) {
			nextLinkAbstMsg = linkAbstMsg->nextItem;

			if (linkAbstMsg == linkAbst->firstLinkAbstMsg) {
				linkAbst->firstLinkAbstMsg = linkAbstMsg->nextItem;

				if (linkAbst->firstLinkAbstMsg != 0) {
					linkAbst->firstLinkAbstMsg->prevItem = 0;
				}

			}
			else if (linkAbstMsg->nextItem == 0) {
				linkAbstMsg->prevItem->nextItem = 0;
			}
			else {
				linkAbstMsg->prevItem->nextItem = linkAbstMsg->nextItem;
				linkAbstMsg->nextItem->prevItem = linkAbstMsg->prevItem;
			};

			linkAbst->numberLinks--;
			delete linkAbstMsg;
			return(nextLinkAbstMsg);
		}
		else {
			SYSTEM->runtimerror(&identity.get_identity(), "remove_underlyingLink", "Underlying_link_not_found", SYS_ERR_HARD);
			return(0);
		};

	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "remove_underlyingLink", "Link_abstraction_not_found", SYS_ERR_HARD);
		return(0);
	};

};

int LinkAbstraction::add_peeringNode(Link *horLink, Identity_s *linkId, Identity_s *nodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, add_peeringNode\n");}

	LinkAbstInfo_s *linkAbst;
	LinkAbstMsg_s *linkAbstMsg;
	int i, numberPeers;
	bool peerFound;

	linkAbst = this->find_linkAbstInfo(&horLink->get_identity(), 0, 0);

	if (linkAbst != 0) {
		linkAbstMsg = this->find_underlyingLink(linkAbst, linkId);

		if (linkAbstMsg != 0)  {
			numberPeers = linkAbstMsg->linkAbstractionBody.numberPeers;

			if (numberPeers < MAX_LINKENDPOINTS - 1) {  // Ensure there is space to list one more peer
				peerFound = false;

				for (i = 0; i < numberPeers && peerFound == false; i++) {

					if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[i].name, nodeId->name) == true) {
						peerFound = true;
					}

				}

				if (peerFound == false) {
					linkAbstMsg->linkAbstractionBody.peeringNodes[numberPeers] = *nodeId;
					linkAbstMsg->linkAbstractionBody.numberPeers++;
					return(numberPeers);  // Returns the index to where the new peer is stored
				}
				else {
					SYSTEM->runtimerror(&identity.get_identity(), "add_peeringNode", "Peering_node_already_listed", SYS_ERR_HARD);
					return(-1);
				};

			}
			else {
				SYSTEM->runtimerror(&identity.get_identity(), "add_peeringNode", "Can't_add_one_more_peer", SYS_ERR_HARD);
				return(-1);
			};

		}
		else {
			SYSTEM->runtimerror(&identity.get_identity(), "add_peeringNode", "Underlying_link_not_listed", SYS_ERR_HARD);
			return(-1);
		};

	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "add_peeringNode", "no_matching_linkabstraction", SYS_ERR_HARD);
		return(-1);
	};

};

int LinkAbstraction::remove_peeringNode(Link *horLink, Identity_s *linkId, Identity_s *nodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, remove_peeringNode\n");}

	LinkAbstInfo_s *linkAbst;
	LinkAbstMsg_s *linkAbstMsg;
	int numberPeers, j, k;
	bool peerFound;

	linkAbst = this->find_linkAbstInfo(&horLink->get_identity(), linkId, nodeId);

	if (linkAbst != 0) {
		linkAbstMsg = this->find_underlyingLink(linkAbst, linkId);

		numberPeers = linkAbstMsg->linkAbstractionBody.numberPeers;
		peerFound = false;
		j = 0;

		while (j < numberPeers && peerFound == false) {

			if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[j].name, nodeId->name) == true) {
				peerFound = true;

				if (numberPeers > 1 && j < (numberPeers-1)) {  // There are at least two peers and the one to be removed is not the last one
					// Shift peers
					k = j+1;

					while (k < numberPeers) {
						linkAbstMsg->linkAbstractionBody.peeringNodes[k-1] = linkAbstMsg->linkAbstractionBody.peeringNodes[k];
						k++;
					}

				}

				linkAbstMsg->linkAbstractionBody.numberPeers--;
			}

			j++;
		};

		return(0);
	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "remove_peeringNode", "no_matching_linkabstraction,_AND/OR_linkId,_AND/OR_nodeId", SYS_ERR_HARD);
		return(-1);
	};

};

LinkAbstInfo_s *LinkAbstraction::checkIfLinkAbst_exists(Link *horLink) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, checkIfLinkAbst_exists\n");}
	LinkAbstInfo_s *linkAbst, *foundLinkAbst;
	bool linkExists;

	linkAbst = firstLinkAbstraction;
	linkExists = false;
	foundLinkAbst = 0;

	while (linkAbst != 0 && linkExists == false) {

		if (linkAbst->horLinkRef == horLink) {
			linkExists = true;
			foundLinkAbst = linkAbst;
		}

		linkAbst = linkAbst->nextItem;
	}

	return(foundLinkAbst);
};

LinkAbstInfo_s *LinkAbstraction::find_linkAbstInfo(Identity_s *horLinkId, Identity_s *underlyingLinkId, Identity_s *superNodeId) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, find_linkAbstInfo\n");}

	// Any of linkId, underlyingLinkId or superNodeId can be 0, but not all of them
	LinkAbstInfo_s *linkAbst;
	LinkAbstMsg_s *linkAbstMsg;
	int j;
	bool horLinkExists, underlyingLinkExists, superNodeExists;

	linkAbst = firstLinkAbstraction;
	horLinkExists = underlyingLinkExists = superNodeExists = false;

	if (horLinkId != 0) {
		// Find linkAbstraction
		while (linkAbst != 0 && horLinkExists == false) {

			if (globalNameSpace->check_ifEqual(linkAbst->horLinkRef->get_identity().name, horLinkId->name) == true) {
				horLinkExists = true;
			}
			else {
				linkAbst = linkAbst->nextItem;
			};

		};

	};

	if (horLinkExists == false && horLinkId != 0) {
		linkAbst = 0;
	}
	else {

		if (underlyingLinkId != 0) {

			if (horLinkExists == true) {
				// Find underlying link
				underlyingLinkExists = false;
				linkAbstMsg = linkAbst->firstLinkAbstMsg;

				while (linkAbstMsg != 0 && underlyingLinkExists == false) {

					if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.linkId.name, underlyingLinkId->name) == true) {
						underlyingLinkExists = true;
					}
					else {
						linkAbstMsg = linkAbstMsg->nextItem;
					};

				}

			}
			else if (horLinkId == 0) {
				// Find underlying link
				linkAbst = firstLinkAbstraction;
				underlyingLinkExists = false;

				while (linkAbst != 0 && underlyingLinkExists == false) {
					linkAbstMsg = linkAbst->firstLinkAbstMsg;

					while (linkAbstMsg != 0 && underlyingLinkExists == false) {

						if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.linkId.name, underlyingLinkId->name) == true) {
							underlyingLinkExists = true;
						}
						else {
							linkAbstMsg = linkAbstMsg->nextItem;
						};
					}

					if (underlyingLinkExists == false) {
						linkAbst = linkAbst->nextItem;
					}

				};

			};  // ENDIF horLinkId, horLinkExists

		};

	};

	if ((horLinkExists == false && horLinkId != 0) || (underlyingLinkExists == false && underlyingLinkId != 0)) {
		linkAbst = 0;
	}
	else {

		if (superNodeId != 0) {

			if (horLinkExists == true && underlyingLinkExists == true) {
				// Look for superNodeId
				superNodeExists = false;

				for (j = 0; j < linkAbstMsg->linkAbstractionBody.numberPeers && superNodeExists == false; j++) {

					if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[j].name, superNodeId->name) == true) {
						superNodeExists = true;
					}

				};

			}
			else if (horLinkExists == true && underlyingLinkId == 0) {
				// Look for superNodeId in any of the underlying links
				superNodeExists = false;
				linkAbstMsg = linkAbst->firstLinkAbstMsg;

				while (linkAbstMsg != 0 && superNodeExists == false) {

					for (j = 0; j < linkAbstMsg->linkAbstractionBody.numberPeers && superNodeExists == false; j++) {

						if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[j].name, superNodeId->name) == true) {
							superNodeExists = true;
						}

					};

					linkAbstMsg = linkAbstMsg->nextItem;
				};

			}
			else if (horLinkId == 0 && underlyingLinkId == 0) {
				// Look for superNodeId in any of the linkabstractions

				linkAbst = firstLinkAbstraction;
				superNodeExists = false;

				while (linkAbst != 0 && superNodeExists == false) {
					linkAbstMsg = linkAbst->firstLinkAbstMsg;

					while (linkAbstMsg != 0 && superNodeExists == false) {

						for (j = 0; j < linkAbstMsg->linkAbstractionBody.numberPeers && superNodeExists == false; j++) {

							if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[j].name, superNodeId->name) == true) {
								superNodeExists = true;
							}

						};

						linkAbstMsg = linkAbstMsg->nextItem;
					};

					if (superNodeExists == false) {
						linkAbst = linkAbst->nextItem;
					}

				};

			};  // ENDIF horLink, underlyingLink

		};  // ENDIF superNodeId

	};

	return(linkAbst);
};

LinkAbstInfo_s *LinkAbstraction::get_nextLinkAbst(Identity_s *horLinkId, Identity_s *superNodeId, bool reset) {  // NB!!! This must tun until all linkabstractions for this supernode have been found
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, get_nextLinkAbst\n");}

	// Either or both of horLinkId and superNodeId might be 0
	LinkAbstInfo_s *currentLinkAbst;
	LinkAbstMsg_s *linkAbstMsg;
	int j;
	bool linkAbstFound;

	if (horLinkId != 0) {

		if (horLinkId->name.name == 3320 && this->thisNode->get_identity().name.name == 10285) {
			cout << "\ngetNextLinkabst!\n";
		}

	}

	if (nextLinkAbstraction == 0 || reset == true) {
		nextLinkAbstraction = firstLinkAbstraction;
		return(0);
	}
	else {
		// Find next linkabstraction for this superNode
		linkAbstFound = false;

		while (linkAbstFound == false && nextLinkAbstraction != 0) {
			currentLinkAbst = nextLinkAbstraction;
			linkAbstMsg = currentLinkAbst->firstLinkAbstMsg;

			while (linkAbstMsg != 0 && linkAbstFound == false) {

				if (horLinkId != 0) {
					
					if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.linkId.name, horLinkId->name) == true && superNodeId == 0) {
						linkAbstFound = true;
					}
					else if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.linkId.name, horLinkId->name) == true && superNodeId != 0) {
					
						for (j = 0; j < linkAbstMsg->linkAbstractionBody.numberPeers && linkAbstFound == false; j++) {

							if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[j].name, superNodeId->name) == true) {
								linkAbstFound = true;
							}

						}

					};

				}
				else if (superNodeId != 0) {

					for (j = 0; j < linkAbstMsg->linkAbstractionBody.numberPeers && linkAbstFound == false; j++) {

						if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[j].name, superNodeId->name) == true) {
							linkAbstFound = true;
						}

					};

				}
				else {  // Both horLinkId and superNodeId are 0
					linkAbstFound = true;
				};  // ENDIF horLinkId

				linkAbstMsg = linkAbstMsg->nextItem;
			};  // ENDWHILE linkAbstMsg, linkAbstFound

			nextLinkAbstraction = nextLinkAbstraction->nextItem;
		};  // ENDWHILE linkAbstFound

		if (linkAbstFound == true) {
			return(currentLinkAbst);
		}
		else {
			nextLinkAbstraction = firstLinkAbstraction;
			return(0);
		};

	};

};

LinkAbstMsg_s *LinkAbstraction::find_underlyingLink(LinkAbstInfo_s *linkAbstInfo, Identity_s *underlyingLinkId) { 
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, find_underlyingLink\n");}

	LinkAbstMsg_s *linkAbstMsg;
	bool linkFound;

	linkAbstMsg = linkAbstInfo->firstLinkAbstMsg;
	linkFound = false;

	while (linkAbstMsg != 0 && linkFound == false) {

		if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.linkId.name, underlyingLinkId->name) == true) {
			linkFound = true;
		}
		else {
			linkAbstMsg = linkAbstMsg->nextItem;
		};

	}

	if (linkFound == true) {
		return(linkAbstMsg);
	}
	else {
		return(0);
	};

};


int LinkAbstraction::get_currentNumberLinkAbst() {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, get_currentNumberLinkAbst\n");}
	return(currentNumberLinkAbstractions);
};

int LinkAbstraction::update_linkAbstractionStatus(Identity_s *infId, Identity_s *nodeId, LinkAbstractionInfo_s *linkAbstractionInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, update_linkAbstractionStatus\n");}
	string extName;
	LinkAbstInfo_s *linkAbstInfo;
	LinkAbstMsg_s *linkAbstMsg;
	ReissueInfo_s reissueInfo;
	int i;

	linkAbstInfo = this->find_linkAbstInfo(&linkAbstractionInfo->linkAbstraction->get_identity(), 0, 0);

	if (linkAbstInfo != 0) {  // This matches an existing link abstraction

		if (linkAbstractionInfo->msgType == LINK_ABSTRACTION) {  // This is a new version of an existing link abstraction, could potentially be for a new underlying link
			linkAbstMsg = this->find_underlyingLink(linkAbstInfo, &linkAbstractionInfo->linkId);

			if (linkAbstMsg != 0) {
				// Update info about peers
				for (i = 0; i < linkAbstractionInfo->numberDest; i++) {
					linkAbstMsg->linkAbstractionBody.peeringNodes[i] = linkAbstractionInfo->destNodes[i];
				}

				linkAbstMsg->linkAbstractionBody.numberPeers = linkAbstractionInfo->numberDest;
			}
			else {  // This is a new underlying link to be addded
				this->add_underlyingLink(linkAbstInfo->horLinkRef, &linkAbstractionInfo->linkId, &linkAbstractionInfo->origNode);

				linkAbstMsg = this->find_underlyingLink(linkAbstInfo, &linkAbstractionInfo->linkId);

				for (i = 0; i < linkAbstractionInfo->numberDest; i++) {
					linkAbstMsg->linkAbstractionBody.peeringNodes[i] = linkAbstractionInfo->destNodes[i];
				}

				linkAbstMsg->linkAbstractionBody.numberPeers = linkAbstractionInfo->numberDest;
			};

			linkAbstMsg->currentVersion = linkAbstMsg->linkAbstractionBody.version = linkAbstractionInfo->version;
			linkAbstMsg->linkAbstRefreshBody.version = linkAbstractionInfo->version;
			linkAbstMsg->linkAbstRefreshBody.refreshCount = 0;
			linkAbstMsg->currentReissueCount = linkAbstMsg->reissueCount = 0;
			linkAbstMsg->lastTicksRead = SYSTEM->getTicks();
			linkAbstMsg->timeToLive = linkAbstractionInfo->timeToLive;
		}
		else if (linkAbstractionInfo->msgType == LINK_ABST_REFRESH) { // Check whether a reissueing might be needed
			linkAbstMsg = this->find_underlyingLink(linkAbstInfo, &linkAbstractionInfo->linkId);

			if ((linkAbstMsg != 0 && linkAbstMsg->currentVersion != linkAbstractionInfo->version) || linkAbstMsg == 0) {
				reissueInfo.initialized = true;
				reissueInfo.processed = false;
				reissueInfo.issueNode = linkAbstractionInfo->origNode.nodeId;
				reissueInfo.reissueMsg = LINK_ABSTRACTION;
				reissueInfo.version = linkAbstractionInfo->version;
				reissueInfo.refreshCount = linkAbstractionInfo->refreshCount;
				reissueInfo.linkAbstraction = linkAbstractionInfo->linkAbstraction;
				reissueInfo.linkId = linkAbstractionInfo->linkId;
				this->thisNode->reissueMsgMgmt_linkAbst(&reissueInfo);
			}
			else {  // This is a "normal" refresh
				linkAbstMsg = this->find_underlyingLink(linkAbstInfo, &linkAbstractionInfo->linkId);
				linkAbstMsg->linkAbstRefreshBody.refreshCount = linkAbstractionInfo->refreshCount;  // For link abstractions there is not really a possibility of receiving duplicates, which is different from the other message types
				linkAbstMsg->timeToLive = linkAbstractionInfo->timeToLive;
			};

		};

	}
	else if (linkAbstractionInfo->msgType == LINK_ABSTRACTION) {  // This is a new link abstraction, add this new linkabstraction if linkendpoints can be added

		if (linkAbstractionInfo->linkAbstraction->get_currentNumberLinkEndpoints() < linkAbstractionInfo->linkAbstraction->get_linkTraits().maxLinkEndpoints) {

			if (this->thisNode->get_subNodeRef()->get_myNodeInfo()->coreNode == true) {
				extName = SYSTEM->find_linkExtName(&linkAbstractionInfo->linkId);
				linkAbstInfo = add_linkAbstraction(linkAbstractionInfo->linkAbstraction, false, &linkAbstractionInfo->origNode.nodeId, extName);
			}
			else {
				linkAbstInfo = add_linkAbstraction(linkAbstractionInfo->linkAbstraction, false, &linkAbstractionInfo->origNode.nodeId, linkAbstractionInfo->linkId.nickName);
			};

			this->add_underlyingLink(linkAbstInfo->horLinkRef, &linkAbstractionInfo->linkId, &linkAbstractionInfo->origNode);
			linkAbstMsg = this->find_underlyingLink(linkAbstInfo, &linkAbstractionInfo->linkId);

			for (i = 0; i < linkAbstractionInfo->numberDest; i++) {
				linkAbstMsg->linkAbstractionBody.peeringNodes[i] = linkAbstractionInfo->destNodes[i];
			}

			linkAbstMsg->linkAbstractionBody.numberPeers = linkAbstractionInfo->numberDest;
			linkAbstMsg->currentVersion = linkAbstMsg->linkAbstractionBody.version = linkAbstractionInfo->version;
			linkAbstMsg->linkAbstRefreshBody.refreshCount = 0;
			linkAbstMsg->currentReissueCount = linkAbstMsg->reissueCount = 0;
			linkAbstMsg->lastTicksRead = SYSTEM->getTicks();
			linkAbstMsg->timeToLive = linkAbstractionInfo->timeToLive;
		}
		// Discard message if linkendpoints can't be added and wait for another one, can be tricky if we throw away a LINK_ABSTRACTION message, then we will only receive REFRESH messages!!!

	}
	else if (linkAbstractionInfo->msgType == LINK_ABST_REFRESH) {  //  Request reissueing
		reissueInfo.initialized = true;
		reissueInfo.processed = false;
		reissueInfo.issueNode = linkAbstractionInfo->origNode.nodeId;
		reissueInfo.reissueMsg = LINK_ABSTRACTION;
		reissueInfo.version = linkAbstractionInfo->version;
		reissueInfo.linkAbstraction = linkAbstractionInfo->linkAbstraction;
		reissueInfo.linkId = linkAbstractionInfo->linkId;
		this->thisNode->reissueMsgMgmt_linkAbst(&reissueInfo);
	};

	return(0);
};

int LinkAbstraction::reissue_linkAbstractionStatus(NodeInterface *nodeInf, ReissueInfo_s *reissueInfo) {
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, reissue_linkAbstractionStatus\n");}
	LinkAbstInfo_s *linkAbstInfo;
	LinkAbstMsg_s *linkAbstMsg;

	linkAbstInfo = this->find_linkAbstInfo(&reissueInfo->linkAbstraction->get_identity(), &reissueInfo->linkId, &reissueInfo->issueNode);
	
	if (linkAbstInfo != 0) {
		linkAbstMsg = this->find_underlyingLink(linkAbstInfo, &reissueInfo->linkId);

		if (linkAbstMsg != 0) {
			linkAbstMsg->reissueCount++;
		}
		else  {
			SYSTEM->runtimerror(&identity.get_identity(), "reissue_linkAbstractionStatus", "Unknown_underlying_link", SYS_ERR_HARD);
			return(-1);
		};

	}
	else {
		SYSTEM->runtimerror(&identity.get_identity(), "reissue_linkAbstractionStatus", "Unknown_linkAbstraction", SYS_ERR_HARD);
		return(-1);
	};

	return(0);
};

void LinkAbstraction::CALLBACK_tickZero(void *parameters, int secret) {
	if (SYS_threadTrace== true) { SYSTEM->threadTrace(&identity.get_identity(), &this->thisNode->get_identity());}
	LinkAbstInfo_s *linkAbst;
	LinkAbstMsg_s *linkAbstMsg;

	CALLBACK_update_linkAbstraction();

	// Update refreshCounts for each underlying link for each linkabstraction
	linkAbst = firstLinkAbstraction;

	while (linkAbst != 0) {
		linkAbstMsg = linkAbst->firstLinkAbstMsg;

		while (linkAbstMsg != 0) {
			linkAbstMsg->ticksDiff.tickPoint += SYSTEM->subTicks(SYSTEM->getTicks(), linkAbstMsg->lastTicksRead).tickPoint;
			linkAbstMsg->lastTicksRead = SYSTEM->getTicks();

			if (linkAbstMsg->ticksDiff.tickPoint > SYSTEM->msToTick(GP_LINKABST_INTERVAL).tickPoint) {
				linkAbstMsg->linkAbstRefreshBody.refreshCount++;
			}

			linkAbstMsg = linkAbstMsg->nextItem;
		};

		linkAbst = linkAbst->nextItem;
	};

	callbackRef = SYSTEM->ticksQueue(this, 0, SYSTEM->jitterbug(linkAbstTicks), CB_LINKABST, 0);
};

void LinkAbstraction::CALLBACK_update_linkAbstraction() {  // This function is only called upon for nodes who are NOT core nodes
	if (SYS_funcTrace== true) { SYSTEM->funcTrace("LinkAbstraction, CALLBACK_update_linkAbstraction\n");}

	Node *subNode;
	Link *horLinkRef;
	RemoteTopologyItem_s *remTopItem;
	int i, j, k, numberNodeInf, numberNeighbors, peerNodeIndex;
	LinkAbstInfo_s *linkAbstInfo, oldLinkAbstInfo, *linkAbstInfoLink;
	LinkAbstMsg_s *linkAbstMsg;
	string input, extName;
	bool peerNodeFound;

	subNode = thisNode->get_subNodeRef();

	if (subNode != 0) {

		if (subNode->check_domainConsistency() == true) {
			remTopItem = thisNode->get_subNodeRef()->getNext_domainNode(false);
		}
		else {
			remTopItem = 0;
		};

	}
	else {
		remTopItem = 0;
	};

//	cout << " superNode: " << thisNode->get_myNodeInfo()->nodeId.name.name << " subNode: " << thisNode->get_subNodeRef()->get_myNodeInfo()->nodeId.name.name << "\n";

/*
The following link abstraction cases are supported with existing code:
- One link abstraction for one or more underlying links towards the same superNode (depends on configuration if there is one or more underlying links(MAX_LINKENDPOINTS_VL))
- One link abstraction for one underlying link towards one or more superNodes (depends on configuratiun if there is more than one superNode (MAX_LINKENDPOINTS_VL))
What is not supported:
- One link abstraction for the grouping of several underlying links towards several superNodes

SET all relations in all linkabstractions to non-valid

	DO for all nodes in domain
		
		FOR each node interface
			
			IF domain border THEN
				
				IF node is link builder THEN
					
					FOR each neighbor
						
						IF neighbor has a valid supernode AND the ids of supernodes are different between local supernode and the remote THEN
							check whether there is a linkabstraction for this peering supernode

							IF no existing linkabstraction THEN
								check if there is a linkabstraction for the underlying link

								IF no existing linkabstraction THEN
									add as a new linkabstraction together with underlying link and peering node
									set relation to validated
								ELSE (there is a linkabstraction for this underlying link)
									find the linkAbstMsg that exists for this linkabstraction and underlying link

									IF another supernode can be accomodated for this linkabstraction THEN
										add the supernode as a peering node for this underlying link and linkabstraction
										update linkAbstMsg version if needed
										set relation to validated
									ELSE
										add a new linkabstraction together with underlying link and peering node
										set relation to validated
									ENDIF

								ENDIF

							ELSE (there is a linkabstraction for this supernode)
								check if there is a linkabstraction for the underlying link and peering supernode

								IF no existing linkabstraction THEN (so there is a linkabstraction for the peering supernode but for another underlying link)
									
									IF peering supernode is attached to the found linkabstraction THEN
										
										IF another underying link can be accomodated for this linkabstraction THEN  (Why this???)
											add underlying link and peering node for this linkabstraction
											set relation to validated
										ELSE
											add a new linkabstraction together with underlying link and peering nodes
											set relation to validated
										ENDIF

									ENDIF

								ELSE (so there is a linkabstraction for this underlying link)
									
									IF peering node can be found for this underlying link THEN
										set relation to validated
									ENDIF

								ENDIF

							ENDIF (linkabstraction exists (superNodeId))

						ENDIF (neighbor check, supernode)

					ENDFOR neighbors

				ENDIF linkBuilder

			ENDIF (domain border)

		ENDFOR (interfaces)

	ENDDO (nodes in domain)

	DO for all linkabstractions

		FOR each underlying link

			FOR each peering node
			
			IF relation is not validated THEN
				remove relation
			ENDIF

		ENDFOR

		IF number of peering nodes is 0 THEN
			update TTL for linkAbstMsg
		ENDIF

	ENDDO
*/

	linkAbstInfo = firstLinkAbstraction;

	while (linkAbstInfo != 0) {
		linkAbstMsg = linkAbstInfo->firstLinkAbstMsg;
		
		while (linkAbstMsg != 0) {

			for (i = 0; i < linkAbstMsg->linkAbstractionBody.numberPeers; i++) {

				if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[i].name, thisNode->get_identity().name) == true) {
					linkAbstMsg->linkAbstractionBody.peerValidated[i] = true;
				}
				else {
					linkAbstMsg->linkAbstractionBody.peerValidated[i] = false;
				};

			}

			linkAbstMsg = linkAbstMsg->nextItem;
		}

		linkAbstInfo = linkAbstInfo->nextItem;
	}

	while (remTopItem != 0) {
//		cout << " remTopItem: " << remTopItem->origNode.nodeId.name.name << "\n";
		numberNodeInf = remTopItem->nodeTopology.numberNodeInf;

		for (i = 0; i < numberNodeInf; i++) {

//			cout << "   localDomainLevel: " << remTopItem->nodeTopology.interfaces[i].localDomainLevel << " domainLevel: " << thisNode->get_myNodeInfo()->nodeTraits.domainLevel << "\n";
			if (remTopItem->nodeTopology.interfaces[i].localDomainLevel <= thisNode->get_myNodeInfo()->nodeTraits.domainLevel) {
//				cout << "     Domain interface\n";

				// Check if this node shall create and manage the horizontal link
				if (remTopItem->nodeTopology.interfaces[i].linkBuilder == true) {
//					cout << "       linkBuilder true, create link\n";
					// This is a domain interface, check whether there is a peering supernode for each neighbor. NB!!! Will only work as long as all neighbors belong to the same peering domain for one and the same node interface!!!
					numberNeighbors = remTopItem->nodeTopology.interfaces[i].numberNeighbors;

					for (j = 0; j < numberNeighbors; j++) {
//						cout << "         localSuperNode: " << remTopItem->nodeTopology.interfaces[i].localSuperNodeId.name.name << " remoteSuperNode: " << remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId.name.name << "\n";

						if (globalNameSpace->check_ifValid(remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId.name) == true && globalNameSpace->check_ifEqual(remTopItem->nodeTopology.interfaces[i].localSuperNodeId.name, remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId.name) == false) {
//							cout << "           peering Node\n";
							// There is a peering supernode for this neighbor, check whether a peering node interface and link exists
							linkAbstInfo = this->find_linkAbstInfo(0, 0, &remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId);

							if (linkAbstInfo == 0) {
//								cout << "             linkAbstInfo == 0, First if, superPeer doesn't exist\n";
								linkAbstInfo = this->find_linkAbstInfo(0, &remTopItem->nodeTopology.interfaces[i].linkId, 0);  // Checking whether this link might be part of another link abstraction for another superNode

								if (linkAbstInfo == 0) {
//									cout << "               linkAbstInfo == 0, Second if, underlying link doesn't exist\n";

									if (this->thisNode->get_subNodeRef()->get_myNodeInfo()->coreNode == true) {
										extName = SYSTEM->find_linkExtName(&remTopItem->nodeTopology.interfaces[i].linkId);
										linkAbstInfo = this->add_linkAbstraction(0, true, &thisNode->get_myNodeInfo()->nodeId, extName);
									}
									else {
										linkAbstInfo = this->add_linkAbstraction(0, true, &thisNode->get_myNodeInfo()->nodeId, remTopItem->nodeTopology.interfaces[i].linkId.nickName);
									};

									linkAbstMsg = this->add_underlyingLink(linkAbstInfo->horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, thisNode->get_myNodeInfo());
									peerNodeIndex = this->add_peeringNode(linkAbstInfo->horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, &remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId);
									linkAbstMsg->linkAbstractionBody.peerValidated[peerNodeIndex] = true;
								}
								else { // There is a link abstraction available which can be extended with one more endpoint to accomodate for the fact that the underlying link connects with several supernodes
									// Add this superNode to the link abstraction if this node is a linkbuilder
//									cout << "               linkAbstInfo == 0, Second else, underlying link exists\n";
									linkAbstMsg = this->find_underlyingLink(linkAbstInfo, &remTopItem->nodeTopology.interfaces[i].linkId);

									if (linkAbstMsg->linkAbstractionBody.numberPeers < (linkAbstInfo->horLinkRef->get_linkTraits().maxLinkEndpoints - 1)) {
//										cout << "                 linkAbstInfo != 0, Second else, first if, first if, add peering node\n";
										peerNodeIndex = this->add_peeringNode(linkAbstInfo->horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, &remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId);
										linkAbstMsg->linkAbstractionBody.peerValidated[peerNodeIndex] = true;

										if (linkAbstMsg->currentVersion == linkAbstMsg->linkAbstractionBody.version) {  // Only update ersion in case version number has NOT been updated
//											cout << "                   linkAbstInfo != 0, Second else, first if, first if, update version\n";
											linkAbstMsg->linkAbstractionBody.version++;
											linkAbstMsg->linkAbstRefreshBody.version++;
											linkAbstMsg->linkAbstRefreshBody.refreshCount = 0;
											// When and where to update currentVersion??? (now in GenericProtocol)
										};

									}
									else {
//										cout << "                 linkAbstInfo != 0, Second else, first if, first else, add link abstraction\n";
										if (this->thisNode->get_subNodeRef()->get_myNodeInfo()->coreNode == true) {
											extName = SYSTEM->find_linkExtName(&remTopItem->nodeTopology.interfaces[i].linkId);
											linkAbstInfo = this->add_linkAbstraction(0, true, &thisNode->get_myNodeInfo()->nodeId, extName);
										}
										else {
											linkAbstInfo = this->add_linkAbstraction(0, true, &thisNode->get_myNodeInfo()->nodeId, remTopItem->nodeTopology.interfaces[i].linkId.nickName);
										};

										linkAbstMsg = this->add_underlyingLink(linkAbstInfo->horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, thisNode->get_myNodeInfo());
										peerNodeIndex = this->add_peeringNode(linkAbstInfo->horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, &remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId);
										linkAbstMsg->linkAbstractionBody.peerValidated[peerNodeIndex] = true;
									};

								};  // ENDIF linkAbstInfo (linkId)

							}
							else {  // There is a linkAbstraction for this peering node, need to check if this link is part of an abstraction, but only need to check if this node is linkbuilder
								// NB!!! In current implementation, there is just one linkabstraction for each peering node, but where one linkabstraction may connect to many peering nodes (see above)
								// Check if this node is linkBuiilder, if not wait for peering node to initiate
//								cout << "             linkAbstInfo != 0, First else, superPeer exists\n";
								horLinkRef = linkAbstInfo->horLinkRef;
								linkAbstInfoLink = this->find_linkAbstInfo(0, &remTopItem->nodeTopology.interfaces[i].linkId, &remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId);

								if (linkAbstInfoLink == 0) {
//									cout << "               linkAbstInfo != 0, no link abstraction for this underlying link\n";

									if (linkAbstInfo->horLinkRef->isNodeAttached(&remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId) == true) {
//										cout << "                 superNodeAttached\n";

										if (linkAbstInfo->numberLinks < (linkAbstInfo->verLinkRef->get_linkTraits().maxLinkEndpoints-1)) {
//											cout << "                   linkAbstInfo == 0, First else, first if, add underlying link\n";
											linkAbstMsg = this->add_underlyingLink(horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, thisNode->get_myNodeInfo());
											peerNodeIndex = this->add_peeringNode(horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, &remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId);
											linkAbstMsg->linkAbstractionBody.peerValidated[peerNodeIndex] = true;
										}
										else {
//											cout << "                   linkAbstInfo == 0, First else, first else, add link abstraction\n";
											if (this->thisNode->get_subNodeRef()->get_myNodeInfo()->coreNode == true) {
												extName = SYSTEM->find_linkExtName(&remTopItem->nodeTopology.interfaces[i].linkId);
												linkAbstInfo = this->add_linkAbstraction(0, true, &thisNode->get_myNodeInfo()->nodeId, extName);
											}
											else {
												linkAbstInfo = this->add_linkAbstraction(0, true, &thisNode->get_myNodeInfo()->nodeId, remTopItem->nodeTopology.interfaces[i].linkId.nickName);
											};

											linkAbstMsg = this->add_underlyingLink(linkAbstInfo->horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, thisNode->get_myNodeInfo());
											peerNodeIndex = this->add_peeringNode(linkAbstInfo->horLinkRef, &remTopItem->nodeTopology.interfaces[i].linkId, &remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId);
											linkAbstMsg->linkAbstractionBody.peerValidated[peerNodeIndex] = true;
										};

									};

								}
								else {  // Already listed, just update timeToLive and set peering node relation to validated
//									cout << "               linkAbstInfo != 0, First else, first else, update ttl for underlying link\n";
									linkAbstMsg = this->find_underlyingLink(linkAbstInfoLink, &remTopItem->nodeTopology.interfaces[i].linkId);
									peerNodeFound = false;

									for (k = 0; k < linkAbstMsg->linkAbstractionBody.numberPeers && peerNodeFound == false; k++) {

										if (globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.peeringNodes[k].name, remTopItem->nodeTopology.interfaces[i].neighbors[j].superNodeId.name) == true) {
											peerNodeIndex = k;
											peerNodeFound = true;
										}

									}

									if (peerNodeFound == true) {
										linkAbstMsg->linkAbstractionBody.peerValidated[peerNodeIndex] = true;
									}

								};

							}; // ENDIF linkAbst exists (superNodeId)

						}; // ENDIF neighbor check

					}; // ENDFOR neighbor

				};  // ENDIF linkBuilder

			}
			else {  // This is not a domain interface, if it has ever been it will time out later on and handled by the while loop further down
				;
			};  // ENDIF domain interface

		};  // ENDFOR node interfaces

		remTopItem = thisNode->get_subNodeRef()->getNext_domainNode(false);
	};  // ENDWHILE remTopItem

	linkAbstInfo = firstLinkAbstraction;

	while (linkAbstInfo != 0) {
		linkAbstMsg = linkAbstInfo->firstLinkAbstMsg;
		
		while (linkAbstMsg != 0) {

			for (i = 0; i < linkAbstMsg->linkAbstractionBody.numberPeers; i++) {
				
				if (linkAbstMsg->linkAbstractionBody.peerValidated[i] == false) {
					this->remove_peeringNode(linkAbstInfo->horLinkRef, &linkAbstMsg->linkAbstractionBody.linkId, &linkAbstMsg->linkAbstractionBody.peeringNodes[i]);
				}

			}

			if (linkAbstMsg->linkAbstractionBody.numberPeers > 0 && globalNameSpace->check_ifEqual(linkAbstMsg->linkAbstractionBody.sourceNode.nodeId.name, thisNode->get_identity().name) == true) { // For the receiving side, time to live is incremented up receoption of LA messages
				linkAbstMsg->timeToLive = SYSTEM->addTicks(SYSTEM->getTicks(), SYSTEM->msToTick(GP_LINKABST_TIMETOLIVE));
			}

			linkAbstMsg = linkAbstMsg->nextItem;
		}

		linkAbstInfo = linkAbstInfo->nextItem;
	}

//	cout << "Ticks: " << SYSTEM->getTicks() << "\n";
//	cin >> input;
	// Check through all linkabstractions and remove all those which have timed out, and remove all exterfnal link fr which this node is linkBuilder
	this->get_nextLinkAbst(0,0, true);
	linkAbstInfo = firstLinkAbstraction;

	while (linkAbstInfo != 0) {
		linkAbstMsg = linkAbstInfo->firstLinkAbstMsg;

		while (linkAbstMsg != 0) {

			if (linkAbstMsg->timeToLive.tickPoint < SYSTEM->getTicks().tickPoint) {  // Shall be removed
				linkAbstMsg = this->remove_underlyingLink(linkAbstInfo->horLinkRef, &linkAbstMsg->linkAbstractionBody.linkId);
			}
			else {
				linkAbstMsg = linkAbstMsg->nextItem;
			};  // ENDIF timeToLive

		}  // ENDWHILE linkAbstMsg

		if (linkAbstInfo->numberLinks == 0) {  // The linkabstraction can be removed, as well as node interface the vertical link and the horizontal link in case of linkBuilder
			linkAbstInfo = this->remove_linkAbstraction(&linkAbstInfo->horLinkRef->get_identity());
		}
		else {

			if (linkAbstInfo->linkBuilder == true) {
				linkAbstInfo->horLinkRef->update_timeToLive(LINK_TIMETOLIVE, &identity.get_identity());
			}

			linkAbstInfo = linkAbstInfo->nextItem;
		};  // ENDIF numberLinks

	};  // ENDWHILE linkAbstInfo

//	if (this->thisNode->get_identity().name.name == 10317 || this->thisNode->get_identity().name.name == 11232) {
//		thisNode->printMe(OBJ_LINKABST);
//	}

};

void LinkAbstraction::CALLBACK_checkTimeToLive() {  // This function is not in use
};

ostream &operator<<(ostream &stream, LinkAbstraction *la) {
	Identity *idp; 
	Identity_s linkAbstId, linkId, nodeId, nodeInfId;
	int i, currentNumberLinkAbst, numberLinks, numberPeers;
	LinkAbstInfo_s *linkAbst;
	LinkAbstMsg_s *linkAbstMsg;

	if (la->thisNode->get_myNodeInfo()->coreNode == false) {
		idp = &la->identity;
		stream << "LinkAbstraction_Status:\n" << idp << "\n";
		currentNumberLinkAbst = la->currentNumberLinkAbstractions;
		stream << "Current number link abstractions: " << currentNumberLinkAbst << "\n";

		linkAbst = la->firstLinkAbstraction;

		while (linkAbst != 0) {

			if (linkAbst->initialized == true) {
				stream << "Link abstraction:\n";
				linkAbstId = linkAbst->horLinkRef->get_identity();
				stream << "  Type: " << linkAbstId.type << " Nickname: " << linkAbstId.nickName << " Name: " << linkAbstId.name.name << "\n";
				nodeId = linkAbst->origNodeId;
				stream << "  OrigNode ID: "<< "  Type: " << nodeId.type << " Nickname: " << nodeId.nickName << " Name: " << nodeId.name.name << "\n";
				nodeInfId = linkAbst->nodeInfRef->get_identity();
				stream << "  Node interface ID: " << "  Type: " << nodeInfId.type << " Nickname: " << nodeInfId.nickName << " Name: " << nodeInfId.name.name << "\n";
				stream << "  LinkBuilder: " << linkAbst->linkBuilder << "\n";
				numberLinks = linkAbst->numberLinks;
				stream << "  Number of underlying links: " << numberLinks << "\n";
				linkAbstMsg = linkAbst->firstLinkAbstMsg;

				while (linkAbstMsg != 0) {
					linkId = linkAbstMsg->linkAbstractionBody.linkId;
					stream << "    Link ID: " << "  Type: " << linkId.type << " Nickname: " << linkId.nickName << " Name: " << linkId.name.name << "\n";
					stream << "    Current version: " << linkAbstMsg->linkAbstractionBody.version << "\n";
					numberPeers = linkAbstMsg->linkAbstractionBody.numberPeers;
					stream << "    Number of peers: " << numberPeers << "\n";

					for (i = 0; i < numberPeers; i++) {
						nodeId = linkAbstMsg->linkAbstractionBody.peeringNodes[i];
						stream << "      Peering node ID: "<< "  Type: " << nodeId.type << " Nickname: " << nodeId.nickName << " Name: " << nodeId.name.name << "\n"; 
					}

					linkAbstMsg = linkAbstMsg->nextItem;
				};

			};

			linkAbst = linkAbst->nextItem;
		};  // ENDWHILE linkAbst

	}
	else {
		stream << "No link abstractions, this node is a core node\n";
	};

	stream << "End_LinkAbstraction_Status\n";

	return stream;
};
